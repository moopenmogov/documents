<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Document Sections</title>
    
    <!-- Office JavaScript API -->
    <script type="text/javascript" src="https://appsforoffice.microsoft.com/lib/1/hosted/office.js"></script>
    
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 16px;
            background-color: #f3f2f1;
            font-size: 14px;
            color: #323130;
        }
        
        .header {
            background: #0078d4;
            color: white;
            padding: 16px;
            margin: -16px -16px 16px -16px;
            border-radius: 0;
            text-align: center;
            font-size: 18px;
            font-weight: 600;
        }
        
        .sections-container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .section-item {
            border-bottom: 1px solid #e1dfdd;
            transition: background-color 0.2s;
        }
        
        .section-item:last-child {
            border-bottom: none;
        }
        
        .section-header {
            padding: 16px;
            cursor: pointer;
            background: #fafafa;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
            color: #0078d4;
            transition: background-color 0.2s;
        }
        
        .section-header:hover {
            background: #f0f8ff;
        }
        
        .section-header.level-1 {
            background: #f8f9fa;
            font-size: 16px;
            padding: 18px 16px;
        }
        
        .section-header.level-2 {
            background: #fbfbfb;
            font-size: 14px;
            padding: 14px 16px 14px 32px;
            color: #106ebe;
        }
        
        .section-header.level-3 {
            background: #fdfdfd;
            font-size: 13px;
            padding: 12px 16px 12px 48px;
            color: #005a9e;
        }
        
        .section-title {
            flex: 1;
            text-align: left;
            word-wrap: break-word;
            overflow: hidden;
        }
        
        .section-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .expand-icon {
            font-size: 12px;
            transition: transform 0.2s;
            color: #605e5c;
        }
        
        .expand-icon.expanded {
            transform: rotate(90deg);
        }
        
        .section-content {
            padding: 16px;
            background: white;
            border-top: 1px solid #e1dfdd;
            font-size: 13px;
            line-height: 1.5;
            color: #605e5c;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .section-content.level-1 {
            padding: 16px;
        }
        
        .section-content.level-2 {
            padding: 12px 16px 12px 32px;
        }
        
        .section-content.level-3 {
            padding: 12px 16px 12px 48px;
        }
        
        .section-content p {
            margin: 0 0 8px 0;
        }
        
        .section-content p:last-child {
            margin-bottom: 0;
        }
        
        .subsections {
            background: white;
        }
        
        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: #605e5c;
            font-style: italic;
        }
        
        .loading {
            text-align: center;
            padding: 20px;
            color: #605e5c;
        }
        
        .refresh-button {
            background: #0078d4;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .refresh-button:hover {
            background: #106ebe;
        }
        
        .status-bar {
            padding: 8px 16px;
            background: #f8f9fa;
            border-top: 1px solid #e1dfdd;
            font-size: 11px;
            color: #605e5c;
            text-align: center;
        }
        
        .section-hierarchy {
            display: none;
        }
        
        .section-hierarchy.visible {
            display: block;
        }
        
        .navigate-icon {
            font-size: 14px;
            color: #0078d4;
            cursor: pointer;
            padding: 4px;
            border-radius: 2px;
            transition: background-color 0.2s;
        }
        
        .navigate-icon:hover {
            background: #e1f5fe;
        }
        
        /* Tab Styles */
        .tab-container {
            display: flex;
            background: #f8f9fa;
            border-bottom: 2px solid #e1dfdd;
            margin: -16px -16px 16px -16px;
        }
        
        .tab-button {
            flex: 1;
            padding: 12px 16px;
            background: none;
            border: none;
            font-size: 14px;
            font-weight: 600;
            color: #605e5c;
            cursor: pointer;
            transition: all 0.2s;
            border-bottom: 3px solid transparent;
        }
        
        .tab-button:hover {
            background: #f0f0f0;
            color: #0078d4;
        }
        
        .tab-button.active {
            color: #0078d4;
            border-bottom-color: #0078d4;
            background: white;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* Variables Styles */
        .variables-container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .variable-form {
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #e1dfdd;
        }
        
        .variable-form h3 {
            margin: 0 0 16px 0;
            color: #323130;
            font-size: 16px;
        }
        
        .form-group {
            margin-bottom: 12px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 4px;
            font-weight: 600;
            color: #323130;
            font-size: 12px;
        }
        
        .form-group input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #d1d1d1;
            border-radius: 4px;
            font-size: 14px;
            box-sizing: border-box;
        }
        
        .form-group input:focus {
            outline: none;
            border-color: #0078d4;
            box-shadow: 0 0 0 1px #0078d4;
        }
        
        .add-button {
            background: #0078d4;
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
            width: 100%;
        }
        
        .add-button:hover {
            background: #106ebe;
        }
        
        .variables-list {
            padding: 20px;
        }
        
        .list-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }
        
        .list-header h3 {
            margin: 0;
            color: #323130;
            font-size: 16px;
        }
        
        .toggle-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .toggle-label {
            font-size: 12px;
            color: #605e5c;
            font-weight: 600;
        }
        
        /* Toggle Switch */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }
        
        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .slider {
            background-color: #0078d4;
        }
        
        input:checked + .slider:before {
            transform: translateX(20px);
        }
        
        .variable-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: #fafafa;
            border: 1px solid #e1dfdd;
            border-radius: 6px;
            margin-bottom: 8px;
            transition: background-color 0.2s;
        }
        
        .variable-item:hover {
            background: #f0f8ff;
        }
        
        .variable-info {
            flex: 1;
        }
        
        .variable-name {
            font-weight: 600;
            color: #0078d4;
            font-size: 14px;
            margin-bottom: 2px;
        }
        
        .variable-value {
            color: #605e5c;
            font-size: 12px;
        }
        
        .variable-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .insert-button {
            background: #28a745;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .insert-button:hover {
            background: #218838;
        }
        
        .delete-button {
            background: #dc3545;
            color: white;
            border: none;
            padding: 6px 8px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .delete-button:hover {
            background: #c82333;
        }
    </style>
</head>

<body>
    <div class="header">
        üìñ Document Navigator & Variables
    </div>
    
    <!-- Tab Navigation -->
    <div class="tab-container">
        <button class="tab-button active" onclick="switchTab('sections')">üìã Sections</button>
        <button class="tab-button" onclick="switchTab('variables')">üîß Variables</button>
    </div>
    
    <!-- Sections Tab -->
    <div id="sectionsTab" class="tab-content active">
        <div class="sections-container">
            <div id="sectionsContent">
                <div class="loading">Loading sections...</div>
            </div>
        </div>
        
        <div class="status-bar">
            <span id="statusText">Ready</span> | 
            <button class="refresh-button" onclick="openFile()">üìÇ Open File</button>
            <button class="refresh-button" onclick="refreshSections()" style="margin-left: 8px;">‚Üª Refresh</button>
            <button class="refresh-button" onclick="syncWithWebViewer()" style="margin-left: 8px;">üåê Sync to Web</button>
        </div>
    </div>
    
    <!-- Variables Tab -->
    <div id="variablesTab" class="tab-content">
        <div class="variables-container">
            <!-- Variable Form -->
            <div class="variable-form">
                <h3>Add Variable</h3>
                <div class="form-group">
                    <label for="varName">Variable Name:</label>
                    <input type="text" id="varName" placeholder="e.g., clientName, date, amount" />
                </div>
                <div class="form-group">
                    <label for="varValue">Value:</label>
                    <input type="text" id="varValue" placeholder="e.g., John Smith, 2024-01-15, $500" />
                </div>
                <button class="add-button" onclick="addVariable()">‚ûï Add Variable</button>
            </div>
            
            <!-- Variables List -->
            <div class="variables-list">
                <div class="list-header">
                    <h3>Variables</h3>
                    <div class="toggle-container">
                        <label class="toggle-switch">
                            <input type="checkbox" id="showValuesToggle" onchange="toggleVariableDisplay()">
                            <span class="slider"></span>
                        </label>
                        <span class="toggle-label">Show Values in Document</span>
                    </div>
                </div>
                <div id="variablesList">
                    <div class="empty-state">No variables defined yet.</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let sections = [];
        let updateTimer = null;
        let variables = {};
        let showValues = false;
        
        Office.onReady((info) => {
            if (info.host === Office.HostType.Word) {
                console.log('Document Navigator & Variables add-in is ready!');
                loadSections();
                loadVariables();
                
                // Set up automatic updates
                Word.run(function (context) {
                    context.document.onContentChanged.add(onContentChanged);
                    return context.sync();
                }).catch(function (error) {
                    console.log('Error setting up content change listener:', error);
                });
            }
        });

        // Tab Management
        function switchTab(tabName) {
            // Remove active class from all tabs and content
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            // Add active class to selected tab and content
            event.target.classList.add('active');
            document.getElementById(tabName + 'Tab').classList.add('active');
        }

        // Variable Management
        function loadVariables() {
            // Load variables from document properties or initialize empty
            variables = {
                'clientName': 'John Smith',
                'projectName': 'Website Redesign', 
                'dueDate': '2024-02-15',
                'amount': '$2,500'
            }; // Example variables
            renderVariables();
        }

        function addVariable() {
            const nameInput = document.getElementById('varName');
            const valueInput = document.getElementById('varValue');
            
            const name = nameInput.value.trim();
            const value = valueInput.value.trim();
            
            if (!name || !value) {
                alert('Please enter both variable name and value.');
                return;
            }
            
            if (name in variables) {
                if (!confirm(`Variable "${name}" already exists. Do you want to update it?`)) {
                    return;
                }
            }
            
            variables[name] = value;
            nameInput.value = '';
            valueInput.value = '';
            
            renderVariables();
            updateVariablesInDocument();
        }

        function deleteVariable(name) {
            if (confirm(`Are you sure you want to delete variable "${name}"?`)) {
                delete variables[name];
                renderVariables();
                updateVariablesInDocument();
            }
        }

        function renderVariables() {
            const container = document.getElementById('variablesList');
            
            if (Object.keys(variables).length === 0) {
                container.innerHTML = '<div class="empty-state">No variables defined yet.</div>';
                return;
            }
            
            let html = '';
            for (const [name, value] of Object.entries(variables)) {
                html += `
                    <div class="variable-item">
                        <div class="variable-info">
                            <div class="variable-name">{{${name}}}</div>
                            <div class="variable-value">${escapeHtml(value)}</div>
                        </div>
                        <div class="variable-controls">
                            <button class="insert-button" onclick="insertVariable('${name}')">üìù Insert</button>
                            <button class="delete-button" onclick="deleteVariable('${name}')">üóë</button>
                        </div>
                    </div>
                `;
            }
            
            container.innerHTML = html;
        }

        async function insertVariable(name) {
            if (!(name in variables)) {
                alert('Variable not found.');
                return;
            }
            
            try {
                await Word.run(async (context) => {
                    const selection = context.document.getSelection();
                    
                    // Insert a content control for the variable
                    const contentControl = selection.insertContentControl();
                    contentControl.tag = `variable:${name}`;
                    contentControl.title = `Variable: ${name}`;
                    contentControl.appearance = Word.ContentControlAppearance.tags;
                    
                    // Set the text based on current display mode
                    const displayText = showValues ? variables[name] : `{{${name}}}`;
                    contentControl.insertText(displayText, Word.InsertLocation.replace);
                    
                    // Style the content control
                    contentControl.font.color = '#0078d4';
                    contentControl.font.bold = true;
                    
                    await context.sync();
                });
                
                updateStatus(`Inserted variable: ${name}`);
            } catch (error) {
                console.error('Error inserting variable:', error);
                updateStatus('Error inserting variable');
            }
        }

        async function toggleVariableDisplay() {
            const toggle = document.getElementById('showValuesToggle');
            showValues = toggle.checked;
            
            try {
                await updateVariablesInDocument();
                updateStatus(showValues ? 'Showing variable values' : 'Showing variable names');
            } catch (error) {
                console.error('Error toggling variable display:', error);
                updateStatus('Error updating variables');
            }
        }

        async function updateVariablesInDocument() {
            try {
                await Word.run(async (context) => {
                    const contentControls = context.document.contentControls;
                    contentControls.load('tag,text');
                    
                    await context.sync();
                    
                    for (let i = 0; i < contentControls.items.length; i++) {
                        const control = contentControls.items[i];
                        
                        if (control.tag && control.tag.startsWith('variable:')) {
                            const varName = control.tag.substring(9); // Remove 'variable:' prefix
                            
                            if (varName in variables) {
                                const displayText = showValues ? variables[varName] : `{{${varName}}}`;
                                control.insertText(displayText, Word.InsertLocation.replace);
                            }
                        }
                    }
                    
                    await context.sync();
                });
            } catch (error) {
                console.error('Error updating variables in document:', error);
            }
        }

        // Enhanced keyboard support
        document.addEventListener('DOMContentLoaded', function() {
            // Add Enter key support for variable form
            document.getElementById('varName').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    document.getElementById('varValue').focus();
                }
            });
            
            document.getElementById('varValue').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    addVariable();
                }
            });
        });

        function onContentChanged() {
            // Debounce updates to avoid too many calls
            clearTimeout(updateTimer);
            updateTimer = setTimeout(loadSections, 1000);
        }

        async function loadSections() {
            try {
                updateStatus('Loading sections...');
                
                await Word.run(async (context) => {
                    const paragraphs = context.document.body.paragraphs;
                    const tables = context.document.body.tables;
                    paragraphs.load('style,text,styleBuiltIn');
                    tables.load('rowCount,rows');
                    
                    await context.sync();
                    
                    sections = [];
                    let currentSection = null;
                    let currentSubsection = null;
                    
                    console.log(`Processing ${paragraphs.items.length} paragraphs and ${tables.items.length} tables`);
                    
                    // Process tables and create simple HTML representations
                    let tableContents = [];
                    
                    console.log('üîç DEBUG: Starting table processing...');
                    
                    if (tables.items.length > 0) {
                        console.log(`üîç DEBUG: Found ${tables.items.length} tables in document`);
                        
                        for (let i = 0; i < tables.items.length; i++) {
                            try {
                                console.log(`üîç DEBUG: Processing table ${i + 1}...`);
                                const table = tables.items[i];
                                table.rows.load('cells');
                                await context.sync();
                                
                                console.log(`üîç DEBUG: Table ${i + 1} has ${table.rows.items.length} rows`);
                                
                                let tableHtml = '<table class="document-table">';
                                for (let rowIndex = 0; rowIndex < table.rows.items.length; rowIndex++) {
                                    const row = table.rows.items[rowIndex];
                                    row.cells.load('body/text');
                                    await context.sync();
                                    
                                    console.log(`üîç DEBUG: Row ${rowIndex + 1} has ${row.cells.items.length} cells`);
                                    
                                    tableHtml += '<tr>';
                                    for (let cellIndex = 0; cellIndex < row.cells.items.length; cellIndex++) {
                                        const cellText = row.cells.items[cellIndex].body.text.trim();
                                        console.log(`üîç DEBUG: Cell [${rowIndex + 1}][${cellIndex + 1}]: "${cellText}"`);
                                        tableHtml += `<td>${cellText}</td>`;
                                    }
                                    tableHtml += '</tr>';
                                }
                                tableHtml += '</table>';
                                
                                console.log(`üîç DEBUG: Generated table HTML: ${tableHtml.substring(0, 100)}...`);
                                tableContents.push(tableHtml);
                            } catch (error) {
                                console.error('üîç DEBUG: Error processing table:', error);
                                tableContents.push('<div class="table-error">Table could not be processed</div>');
                            }
                        }
                    } else {
                        console.log('üîç DEBUG: No tables found in document');
                        
                        // Check if there are table-like structures in paragraphs
                        let potentialTableRows = [];
                        for (let i = 0; i < paragraphs.items.length; i++) {
                            const text = paragraphs.items[i].text.trim();
                            if (text.includes('\t') || text.includes('|') || text.includes('___')) {
                                potentialTableRows.push(text);
                            }
                        }
                        
                        if (potentialTableRows.length > 0) {
                            console.log(`üîç DEBUG: Found ${potentialTableRows.length} potential table rows in paragraphs`);
                            console.log('üîç DEBUG: Sample rows:', potentialTableRows.slice(0, 3));
                            
                            // Create a simple table from tab-separated content
                            let tableHtml = '<table class="document-table">';
                            potentialTableRows.forEach(row => {
                                if (row.includes('\t')) {
                                    const cells = row.split('\t');
                                    tableHtml += '<tr>';
                                    cells.forEach(cell => {
                                        tableHtml += `<td>${cell.trim()}</td>`;
                                    });
                                    tableHtml += '</tr>';
                                } else {
                                    tableHtml += `<tr><td>${row}</td></tr>`;
                                }
                            });
                            tableHtml += '</table>';
                            
                            console.log(`üîç DEBUG: Generated table from paragraphs: ${tableHtml.substring(0, 100)}...`);
                            tableContents.push(tableHtml);
                        }
                    }
                    
                    // Add tables as separate sections first
                    tableContents.forEach((tableHtml, index) => {
                        sections.push({
                            id: `table-${index}`,
                            title: `Table ${index + 1}`,
                            content: [tableHtml],
                            subsections: [],
                            paragraphIndex: -1,
                            level: 1,
                            expanded: true
                        });
                    });
                    
                    for (let i = 0; i < paragraphs.items.length; i++) {
                        const paragraph = paragraphs.items[i];
                        let text = paragraph.text.trim();
                        
                        if (!text) continue;
                        
                        // Get the style name for debugging
                        const styleName = paragraph.style ? paragraph.style.toLowerCase() : '';
                        console.log(`Paragraph ${i}: "${text}" - Style: "${styleName}" - StyleBuiltIn: ${paragraph.styleBuiltIn}`);
                        
                        // Check if this is a heading using multiple approaches - include more styles for testing
                        const isHeading1 = styleName.includes('heading 1') || 
                                          styleName.includes('heading1') ||
                                          styleName === 'heading 1' ||
                                          styleName === 'heading1' ||
                                          styleName === 'heading' ||
                                          paragraph.styleBuiltIn === Word.Style.heading1 ||
                                          paragraph.styleBuiltIn === Word.Style.heading;
                                          
                        const isHeading2 = styleName.includes('heading 2') || 
                                          styleName.includes('heading2') ||
                                          styleName === 'heading 2' ||
                                          styleName === 'heading2' ||
                                          paragraph.styleBuiltIn === Word.Style.heading2;
                                          
                        const isHeading3 = styleName.includes('heading 3') || 
                                          styleName.includes('heading3') ||
                                          styleName === 'heading 3' ||
                                          styleName === 'heading3' ||
                                          paragraph.styleBuiltIn === Word.Style.heading3;
                        
                        // Fallback detection: if no sections found yet and text looks like a heading, treat as heading
                        const possibleHeading = sections.length === 0 && text.length > 0 && text.length < 100;
                        
                        if (isHeading1 || (possibleHeading && !isHeading2 && !isHeading3)) {
                            console.log(`Found Heading 1: "${text}" (Style: ${styleName}, BuiltIn: ${paragraph.styleBuiltIn}, Fallback: ${possibleHeading})`);
                            currentSection = {
                                id: `section-${i}`,
                                title: text,
                                content: [],
                                subsections: [],
                                paragraphIndex: i,
                                level: 1,
                                expanded: false
                            };
                            sections.push(currentSection);
                            currentSubsection = null;
                        } else if (isHeading2) {
                            console.log(`Found Heading 2: "${text}"`);
                            if (currentSection) {
                                currentSubsection = {
                                    id: `subsection-${i}`,
                                    title: text,
                                    content: [],
                                    subsections: [],
                                    paragraphIndex: i,
                                    level: 2,
                                    expanded: false
                                };
                                currentSection.subsections.push(currentSubsection);
                            }
                        } else if (isHeading3) {
                            console.log(`Found Heading 3: "${text}"`);
                            if (currentSubsection) {
                                const subSubsection = {
                                    id: `subsubsection-${i}`,
                                    title: text,
                                    content: [],
                                    subsections: [],
                                    paragraphIndex: i,
                                    level: 3,
                                    expanded: false
                                };
                                currentSubsection.subsections.push(subSubsection);
                            }
                        } else {
                            // Regular content
                            if (currentSubsection && currentSubsection.subsections.length > 0) {
                                // Add to the last sub-subsection
                                const lastSubSub = currentSubsection.subsections[currentSubsection.subsections.length - 1];
                                lastSubSub.content.push(text);
                            } else if (currentSubsection) {
                                // Add to current subsection
                                currentSubsection.content.push(text);
                            } else if (currentSection) {
                                // Add to current section
                                currentSection.content.push(text);
                            }
                        }
                    }
                    
                    console.log(`Found ${sections.length} sections total`);
                    
                    // If no sections found, add a test section to verify the UI works
                    if (sections.length === 0 && paragraphs.items.length > 0) {
                        console.log('No sections detected, adding test section');
                        sections.push({
                            id: 'test-section',
                            title: 'üìã TEST: No sections detected',
                            content: ['Use Word\'s Styles gallery to apply Heading 1, Heading 2, or Heading 3 styles to your text.', 'Or try typing some text and this add-in will auto-detect it.'],
                            subsections: [],
                            paragraphIndex: 0,
                            level: 1,
                            expanded: true
                        });
                    }
                    
                    renderSections();
                    updateStatus(`Found ${sections.length} sections`);
                });
            } catch (error) {
                console.error('Error loading sections:', error);
                updateStatus('Error loading sections');
                document.getElementById('sectionsContent').innerHTML = 
                    '<div class="empty-state">Error loading sections. Please try refreshing.<br><small>Check browser console for details.</small></div>';
            }
        }

        function renderSections() {
            const container = document.getElementById('sectionsContent');
            
            if (sections.length === 0) {
                container.innerHTML = '<div class="empty-state">No sections found.<br>Use Heading 1 style to create sections.</div>';
                return;
            }
            
            let html = '';
            sections.forEach((section, index) => {
                html += renderSection(section, index);
            });
            
            container.innerHTML = html;
        }

        function renderSection(section, index) {
            const contentPreview = section.content.slice(0, 3).join(' ').substring(0, 200);
            const hasContent = section.content.length > 0;
            const hasSubsections = section.subsections.length > 0;
            
            let html = `
                <div class="section-item">
                    <div class="section-header level-${section.level}" onclick="toggleSection('${section.id}')">
                        <div class="section-title">${escapeHtml(section.title)}</div>
                        <div class="section-controls">
                            <span class="navigate-icon" onclick="navigateToSection(${section.paragraphIndex}); event.stopPropagation();" title="Go to section">üìç</span>
                            ${hasContent || hasSubsections ? '<span class="expand-icon" id="icon-' + section.id + '">‚ñ∂</span>' : ''}
                        </div>
                    </div>
                    
                    <div class="section-hierarchy" id="content-${section.id}">
                        ${hasContent ? `<div class="section-content level-${section.level}">${formatContent(section.content)}</div>` : ''}
                        ${hasSubsections ? renderSubsections(section.subsections) : ''}
                    </div>
                </div>
            `;
            
            return html;
        }

        function renderSubsections(subsections) {
            let html = '<div class="subsections">';
            subsections.forEach(subsection => {
                const contentPreview = subsection.content.slice(0, 2).join(' ').substring(0, 150);
                const hasContent = subsection.content.length > 0;
                const hasSubsections = subsection.subsections.length > 0;
                
                html += `
                    <div class="section-item">
                        <div class="section-header level-${subsection.level}" onclick="toggleSection('${subsection.id}')">
                            <div class="section-title">${escapeHtml(subsection.title)}</div>
                            <div class="section-controls">
                                <span class="navigate-icon" onclick="navigateToSection(${subsection.paragraphIndex}); event.stopPropagation();" title="Go to section">üìç</span>
                                ${hasContent || hasSubsections ? '<span class="expand-icon" id="icon-' + subsection.id + '">‚ñ∂</span>' : ''}
                            </div>
                        </div>
                        
                        <div class="section-hierarchy" id="content-${subsection.id}">
                            ${hasContent ? `<div class="section-content level-${subsection.level}">${formatContent(subsection.content)}</div>` : ''}
                            ${hasSubsections ? renderSubsections(subsection.subsections) : ''}
                        </div>
                    </div>
                `;
            });
            html += '</div>';
            return html;
        }

        function formatContent(content) {
            return content.slice(0, 5).map(text => `<p>${escapeHtml(text)}</p>`).join('');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function toggleSection(sectionId) {
            const content = document.getElementById(`content-${sectionId}`);
            const icon = document.getElementById(`icon-${sectionId}`);
            
            if (content && icon) {
                const isVisible = content.classList.contains('visible');
                
                if (isVisible) {
                    content.classList.remove('visible');
                    icon.classList.remove('expanded');
                } else {
                    content.classList.add('visible');
                    icon.classList.add('expanded');
                }
            }
        }

        async function navigateToSection(paragraphIndex) {
            try {
                await Word.run(async (context) => {
                    const paragraphs = context.document.body.paragraphs;
                    const targetParagraph = paragraphs.items[paragraphIndex];
                    
                    if (targetParagraph) {
                        const range = targetParagraph.getRange();
                        range.select();
                        context.document.getSelection().scrollIntoView();
                    }
                    
                    await context.sync();
                });
                
                updateStatus('Navigated to section');
            } catch (error) {
                console.error('Error navigating to section:', error);
                updateStatus('Error navigating to section');
            }
        }

        function refreshSections() {
            loadSections();
        }

        function updateStatus(message) {
            document.getElementById('statusText').textContent = message;
        }

        // API Integration Functions
        async function sendSectionsToAPI() {
            try {
                const response = await fetch('http://localhost:3001/api/document-sections', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        sections: sections,
                        title: 'Word Document'
                    })
                });

                if (response.ok) {
                    const result = await response.json();
                    console.log('Successfully sent sections to API:', result);
                    updateStatus(`Synced ${result.sectionsCount} sections to web viewer`);
                } else {
                    console.error('Failed to send sections to API');
                    updateStatus('Failed to sync with web viewer');
                }
            } catch (error) {
                console.error('Error sending sections to API:', error);
                updateStatus('Error syncing with web viewer');
            }
        }

        // Auto-sync sections to API whenever they're loaded
        const originalLoadSections = loadSections;
        loadSections = function() {
            originalLoadSections.call(this);
            
            // Send sections to API after they're loaded
            setTimeout(() => {
                sendSectionsToAPI();
            }, 1000);
        };

        // Manual sync button functionality
        function syncWithWebViewer() {
            sendSectionsToAPI();
        }

        // Poll for incoming content from web viewer
        async function checkForIncomingContent() {
            try {
                const response = await fetch('http://localhost:3001/api/word-inbound', {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                if (response.ok) {
                    const result = await response.json();
                    if (result.success && result.data) {
                        console.log('Received content from web viewer:', result.data);
                        await writeContentToWord(result.data);
                        updateStatus('Document updated from web viewer');
                    }
                }
            } catch (error) {
                console.error('Error checking for incoming content:', error);
            }
        }

        // Write content from web viewer to Word document
        async function writeContentToWord(data) {
            try {
                await Word.run(async (context) => {
                    // Clear existing content if action is replace
                    if (data.action === 'replace') {
                        context.document.body.clear();
                    }
                    
                    // Add title
                    if (data.sections && data.sections.length > 0) {
                        const titleParagraph = context.document.body.insertParagraph('Software Development Agreement', Word.InsertLocation.end);
                        titleParagraph.style = 'Title';
                        titleParagraph.alignment = Word.Alignment.centered;
                        
                        // Add a blank line
                        context.document.body.insertParagraph('', Word.InsertLocation.end);
                        
                        // Add sections
                        for (const section of data.sections) {
                            await writeSectionToWord(context, section);
                        }
                    }
                    
                    await context.sync();
                });
                
                // Refresh the add-in view
                setTimeout(() => {
                    loadSections();
                }, 1000);
                
            } catch (error) {
                console.error('Error writing content to Word:', error);
                updateStatus('Error writing content to Word');
            }
        }

        // Helper function to write a section to Word
        async function writeSectionToWord(context, section) {
            // Add section heading
            const headingParagraph = context.document.body.insertParagraph(section.title, Word.InsertLocation.end);
            headingParagraph.style = section.level === 1 ? 'Heading 1' : 'Heading 2';
            
            // Add section content
            if (section.content && section.content.length > 0) {
                section.content.forEach(paragraph => {
                    const contentParagraph = context.document.body.insertParagraph(paragraph, Word.InsertLocation.end);
                    contentParagraph.style = 'Normal';
                });
            }
            
            // Add blank line after section
            context.document.body.insertParagraph('', Word.InsertLocation.end);
            
            // Add subsections
            if (section.subsections && section.subsections.length > 0) {
                for (const subsection of section.subsections) {
                    await writeSectionToWord(context, subsection);
                }
            }
        }

        // Open file function
        async function openFile() {
            try {
                updateStatus('Opening file...');
                
                // Create a file input element
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = '.docx,.doc';
                fileInput.style.display = 'none';
                
                fileInput.onchange = async function(e) {
                    const file = e.target.files[0];
                    if (file) {
                        try {
                            updateStatus(`Opening ${file.name}...`);
                            
                            // For Word add-ins, we need to use the Word API to open documents
                            await Word.run(async (context) => {
                                // First, clear the current document
                                context.document.body.clear();
                                
                                // Create a file reader to read the document
                                const reader = new FileReader();
                                
                                reader.onload = async function(event) {
                                    try {
                                        // Use Word's insertFileFromBase64 if available
                                        const base64 = event.target.result.split(',')[1];
                                        context.document.body.insertFileFromBase64(base64, Word.InsertLocation.end);
                                        
                                        await context.sync();
                                        updateStatus(`Opened ${file.name} successfully`);
                                        
                                        // Refresh sections after opening
                                        setTimeout(() => {
                                            loadSections();
                                        }, 1000);
                                        
                                    } catch (error) {
                                        console.error('Error inserting file:', error);
                                        updateStatus('Error opening file - trying alternative method');
                                        
                                        // Alternative: Just show a message to manually open the file
                                        alert(`Please manually open ${file.name} in Word, then use the Refresh button to sync.`);
                                    }
                                };
                                
                                reader.readAsDataURL(file);
                            });
                            
                        } catch (error) {
                            console.error('Error opening file:', error);
                            updateStatus('Error opening file');
                            
                            // Fallback: Show instructions to manually open
                            alert(`Unable to automatically open ${file.name}. Please:\n1. Open the file manually in Word\n2. Click the Refresh button to sync`);
                        }
                    }
                };
                
                // Trigger file selection
                document.body.appendChild(fileInput);
                fileInput.click();
                document.body.removeChild(fileInput);
                
            } catch (error) {
                console.error('Error in openFile:', error);
                updateStatus('Error opening file');
            }
        }

        // Set up polling for incoming content (every 5 seconds)
        setInterval(checkForIncomingContent, 5000);
    </script>
</body>
</html> 