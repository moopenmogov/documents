<!DOCTYPE html>

<html lang="en">

<head>

    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>OpenGov Contract Redlining - Web Viewer</title>

    <link rel="stylesheet" href="./node_modules/@harbour-enterprises/superdoc/dist/style.css">

    <link rel="stylesheet" href="theme.css">

    <style>

        body {

            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;

            margin: 0;

            padding: 0;

            background: var(--bg-muted);

            color: var(--text-primary);

        }

        
        
        .opengov-header {

            /* Low-saturation gradient theme */
            background: linear-gradient(135deg, #8a8db5, #9ca3af);
            color: white;

            padding: 15px;
            border-radius: 10px;

            text-align: center;

            margin: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);

            display: block !important;

            visibility: visible !important;

            position: relative;

        }

        .coming-soon-badge {

            position: absolute;

            top: 8px;

            left: 8px;

            background: var(--btn-primary, #3b82f6);
            color: white;

            padding: 4px 10px;

            border-radius: 999px;

            font-size: 12px;

            font-weight: 700;

            letter-spacing: .3px;

            box-shadow: 0 2px 6px rgba(0,0,0,0.2);

        }

        

        
        
        .opengov-logo {

            margin-bottom: 20px;

            display: flex;

            justify-content: center;

        }

        
        
        .opengov-text {

            text-align: center;

        }

        
        
        .main-title {

            font-size: 26px;

            font-weight: bold;

            margin: 0 0 10px 0;

            line-height: 1.3;

        }

        
        
        .sub-header {

            font-size: 16px;

            margin: 0;

            opacity: 0.9;

            font-style: italic;

            text-align: center;

        }

        
        
        .controls {

            text-align: center;

            margin: 30px 20px;

        }
        
        

        /* Unified low-saturation theme buttons */
        button, .btn, .button, .doc-action, .btn-open, .btn-secondary {

            background: var(--btn-primary) !important;
            color: #fff !important;

            border: none !important;

            border-radius: 8px !important;

            padding: 8px 12px !important;

            font-weight: 600 !important;

            box-shadow: none !important;

        }

        button:hover, .btn:hover, .button:hover, .doc-action:hover, .btn-open:hover, .btn-secondary:hover { background: var(--btn-primary-hover) !important; }
        
        
        .viewer-container {

            background: white;

            border-radius: 12px;

            padding: 30px;

            min-height: 600px;

            max-width: 1400px;

            margin: 0 auto 40px auto;

            margin-left: 20px;

            margin-right: 20px;

            position: relative;

        }

        
        
        .viewer-container.read-only-mode {

            border: 6px solid transparent;

            box-shadow: 0 4px 16px rgba(0,0,0,0.2), 0 0 20px rgba(220, 53, 69, 0.3);

        }

        
        
        .viewer-container.edit-mode {

            border: 6px solid transparent;

            box-shadow: 0 4px 16px rgba(0,0,0,0.1);

        }

        


        

        
        #superdoc-toolbar {

            border-bottom: 2px solid #e9ecef;

            margin-bottom: 20px;

            padding-bottom: 15px;

        }

        
        
        #superdoc {

            min-height: 500px;

            position: relative;

            background: white;

        }

        


        

        
        .empty-state {

            text-align: center;

            color: #6c757d;

            margin-top: 100px;

            padding: 40px;

        }

        
        
        .empty-state h2 {

            color: #0078d4;

            margin-bottom: 20px;

            font-size: 24px;

        }

        
        
        .empty-state p {

            font-size: 16px;

            line-height: 1.6;

            margin-bottom: 15px;

        }

        


        

        
        .viewer-message {

            background: #ffc107;

            color: #212529;

            padding: 6px 12px;

            text-align: center;

            font-weight: 400;

            margin: 6px 0;

            border-radius: 4px;

            font-size: 13px;

            font-style: italic;

        }/* User Controls Styling */

        .user-controls {

            background: #fff3cd;

            border: 1px solid #ffeaa7;

            border-radius: 8px;

            padding: 15px;

            margin: 20px;

            display: flex;

            justify-content: space-between;

            align-items: center;

            box-shadow: 0 2px 4px rgba(0,0,0,0.1);

        }

        
        
        .current-user {

            display: flex;

            align-items: center;

            gap: 8px;

        }

        
        
        .user-label {

            font-weight: 600;

            color: #856404;

        }

        
        
        .user-name {

            font-weight: bold;

            color: #495057;

        }

        
        
        .user-role {

            background: #fd7e14;

            color: white;

            padding: 2px 8px;

            border-radius: 12px;

            font-size: 12px;

            font-weight: 600;

            text-transform: uppercase;

        }

        
        
        .user-role.viewer {

            background: #dc3545;

        }

        
        
        .user-switcher {

            display: flex;

            align-items: center;

            gap: 10px;

        }

        
        
        .user-switcher label {

            font-weight: 600;

            color: #856404;

            white-space: nowrap;

        }

        
        
        .user-select {

            padding: 6px 12px;

            border: 1px solid #ffc107;

            border-radius: 4px;

            background: white;

            font-size: 14px;

            min-width: 200px;

        }

        
        
        .user-select:focus {

            outline: none;

            border-color: #fd7e14;

            box-shadow: 0 0 0 2px rgba(253, 126, 20, 0.25);

        }

        
        
        .document-info {

            background: #f8f9fa;

            padding: 15px;

            border-radius: 8px;

            margin-bottom: 15px;

            border: 1px solid #dee2e6;

            display: flex;

            flex-direction: column;

        }

        
        
        .document-title {

            font-size: 18px;

            font-weight: 600;

            color: #0078d4;

            margin: 0;

            flex-grow: 1;

        }

        
        
        .document-buttons {

            display: flex;

            gap: 15px;

            margin-top: 10px;

            justify-content: flex-start;

        }

        
        
        .btn-notification {

            background: #6c757d;

            color: white;

            padding: 8px 20px;

            border: none;

            border-radius: 6px;

            cursor: pointer;

            font-size: 14px;

            font-weight: 600;

            transition: background-color 0.2s;

            position: relative;

        }

        
        
        .btn-notification:hover {

            background: #5a6268;

        }

        
        
        /* Legacy view latest variant overridden by unified styling */

        .btn-view-latest { }

        .btn-view-latest:hover { }

        
        
        /* Legacy button variants overridden by unified styling above */

        .btn-open { }

        .btn-open:hover { }






        
        .viewer-message {

            background: #ffc107;

            color: #212529;

            padding: 6px 12px;

            text-align: center;

            font-weight: 400;

            margin: 6px 0;

            border-radius: 4px;

            font-size: 13px;

            font-style: italic;

        }/* Button click animation for all buttons */

        .btn-clicked {

            animation: buttonClick 0.3s ease-out !important;

            transform: scale(0.95) !important;

            position: relative !important;

            z-index: 9999 !important;

            will-change: transform, opacity !important;

            animation-fill-mode: both !important;

        }



        @keyframes buttonClick {

            0% { 

                transform: scale(1); 

                opacity: 1;

            }

            30% { 

                transform: scale(0.92); 

                opacity: 0.7;

            }

            60% { 

                transform: scale(0.96); 

                opacity: 0.9;

            }

            100% { 

                transform: scale(1); 

                opacity: 1;

            }

        }




        
        .viewer-message {

            background: #ffc107;

            color: #212529;

            padding: 6px 12px;

            text-align: center;

            font-weight: 400;

            margin: 6px 0;

            border-radius: 4px;

            font-size: 13px;

            font-style: italic;

        }



        /* Apply animation to all button types with stronger specificity */

        button:active, 

        .btn:active, 

        .btn-notification:active, 

        .btn-view-latest:active, 

        .btn-open:active,

        .button:active {

            animation: buttonClick 0.3s ease-out !important;

            position: relative !important;

            z-index: 9999 !important;

            will-change: transform, opacity !important;

        }






        
        .notification-dot {

            position: absolute;

            top: -5px;

            right: -5px;

            background: #dc3545;

            border: 2px solid white;

            border-radius: 50%;

            width: 12px;

            height: 12px;

        }

        


        

        
        .viewer-message {

            background: #ffc107;

            color: #212529;

            padding: 6px 12px;

            text-align: center;

            font-weight: 400;

            margin: 6px 0;

            border-radius: 4px;

            font-size: 13px;

            font-style: italic;

        }        /* Checkout Status Banner - unified pink colors to match Word add-in */
        .checkout-banner {

            background: #ffc1d9;
            color: white;

            padding: 12px 20px;

            text-align: center;

            font-weight: 600;

            font-size: 14px;

            margin: 20px;

            border-radius: 6px;

            border: 2px solid #b02a37;

            box-shadow: 0 2px 8px rgba(220, 53, 69, 0.3);

            display: none;

            animation: slideDown 0.3s ease-out;

        }

        
        
        @keyframes slideDown {

            from {

                transform: translateY(-10px);

                opacity: 0;

            }

            to {

                transform: translateY(0);

                opacity: 1;

            }

        }

        

        
        
        .viewer-message {

            background: #ffc107;

            color: #212529;

            padding: 6px 12px;

            text-align: center;

            font-weight: 400;

            margin: 6px 0;

            border-radius: 4px;

            font-size: 13px;

            font-style: italic;

        }/* Vendor Button Styles */

        /* vendor variant removed; unified styling applies */

        


        

        
        .viewer-message {

            background: #ffc107;

            color: #212529;

            padding: 6px 12px;

            text-align: center;

            font-weight: 400;

            margin: 6px 0;

            border-radius: 4px;

            font-size: 13px;

            font-style: italic;

        }/* Warning Button Styles */

        .btn-warning {

            background: #ff4444 !important;

            border-color: #ff4444 !important;

        }

        
        
        .btn-warning:hover {

            background: #cc3333 !important;

            border-color: #cc3333 !important;

        }

        


        

        
        .viewer-message {

            background: #ffc107;

            color: #212529;

            padding: 6px 12px;

            text-align: center;

            font-weight: 400;

            margin: 6px 0;

            border-radius: 4px;

            font-size: 13px;

            font-style: italic;

        }/* Notification Modal Styles */

        .notification-modal {

            position: fixed;

            top: 0;

            left: 0;

            width: 100%;

            height: 100%;

            z-index: 10000;

            display: flex;

            justify-content: center;

            align-items: center;

        }

        
        
        .notification-modal-backdrop {

            position: absolute;

            top: 0;

            left: 0;

            width: 100%;

            height: 100%;

            background: rgba(0, 0, 0, 0.5);

        }

        
        
        .notification-modal-content {

            background: white;

            border-radius: 8px;

            width: 500px;

            max-width: 90vw;

            max-height: 80vh;

            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);

            position: relative;

            z-index: 1001;

            display: flex;

            flex-direction: column;

        }

        
        
        .notification-modal-header {

            background: #0078d4;

            color: white;

            padding: 20px;

            border-radius: 8px 8px 0 0;

            display: flex;

            justify-content: space-between;

            align-items: center;

        }

        
        
        .notification-modal-title {

            font-size: 18px;

            font-weight: 600;

            margin: 0;

        }

        
        
        .notification-modal-close {

            background: none;

            border: none;

            color: white;

            font-size: 24px;

            cursor: pointer;

            padding: 0;

            width: 30px;

            height: 30px;

            display: flex;

            align-items: center;

            justify-content: center;

            border-radius: 4px;

            transition: background-color 0.2s;

        }

        
        
        .notification-modal-close:hover {

            background: rgba(255, 255, 255, 0.2);

        }

        
        
        .notification-modal-body {

            padding: 20px;

            flex-grow: 1;

            overflow-y: auto;

        }

        
        
        .notification-item {

            padding: 15px;

            border-bottom: 1px solid #e9ecef;

            border-left: 4px solid transparent;

        }

        
        
        .notification-item:last-child {

            border-bottom: none;

        }

        
        
        .notification-item.success {

            border-left-color: #28a745;

            background: #f8fff9;

        }

        
        
        .notification-item.error {

            border-left-color: #dc3545;

            background: #fff8f8;

        }

        
        
        .notification-item.info {

            border-left-color: #17a2b8;

            background: #f8fcff;

        }

        
        
        .notification-message {

            font-size: 14px;

            margin: 0 0 5px 0;

            color: #333;

        }

        
        
        .notification-timestamp {

            font-size: 12px;

            color: #6c757d;

            margin: 0;

        }

        
        
        .no-notifications {

            text-align: center;

            color: #6c757d;

            padding: 40px;

            font-style: italic;

        }






        
        .viewer-message {

            background: #ffc107;

            color: #212529;

            padding: 6px 12px;

            text-align: center;

            font-weight: 400;

            margin: 6px 0;

            border-radius: 4px;

            font-size: 13px;

            font-style: italic;

        }/* Transparent Notification Window Styles */

        .notification-window {

            background: var(--bg-muted);

            border: 1px solid var(--border);

            border-left: 4px solid var(--accent);

            border-radius: 0;

            margin-top: 15px;

            max-height: 200px;

            overflow-y: auto;

            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.03), 0 1px 3px rgba(0, 0, 0, 0.04);

        }



        .notification-window-header {

            background: transparent;

            color: var(--text-muted);

            padding: 6px 12px;

            border-radius: 0;

            font-size: 11px;

            font-weight: 500;

            text-align: left;

            border-bottom: 1px solid var(--border);

            text-transform: uppercase;

            letter-spacing: 0.5px;

        }



        .notification-window-body {

            max-height: 150px;

            overflow-y: auto;

            padding: 0;

        }



        .notification-window .notification-item {

            padding: 6px 12px;

            border-bottom: 1px dotted rgba(108, 117, 125, 0.2);

            background: transparent;

            margin: 0;

            transition: background-color 0.2s ease;

        }



        .notification-window .notification-item:hover {

            background: rgba(255, 255, 255, 0.4);

        }



        .notification-window .notification-item:last-child {

            border-bottom: none;

        }



        .notification-window .notification-item.success {

            border-left: 2px solid #28a745;

            background: linear-gradient(90deg, rgba(40, 167, 69, 0.05), transparent 30%);

        }



        .notification-window .notification-item.error {

            border-left: 2px solid #dc3545;

            background: linear-gradient(90deg, rgba(220, 53, 69, 0.05), transparent 30%);

        }



        .notification-window .notification-item.info {

            border-left: 2px solid #17a2b8;

            background: linear-gradient(90deg, rgba(23, 162, 184, 0.05), transparent 30%);

        }



        .notification-window .notification-message {

            font-size: 11px;

            margin: 0 0 2px 0;

            color: #495057;

            line-height: 1.4;

            font-weight: 400;

        }



        .notification-window .notification-timestamp {

            font-size: 9px;

            color: #868e96;

            margin: 0;

            font-family: 'Courier New', monospace;

        }



        .notification-window .no-notifications {

            padding: 20px 15px;

            font-size: 11px;

            color: #adb5bd;

            text-align: center;

            font-style: italic;

            background: linear-gradient(45deg, rgba(248, 249, 250, 0.3), rgba(233, 236, 239, 0.1));        




        
        .viewer-message {

            background: #ffc107;

            color: #212529;

            padding: 6px 12px;

            text-align: center;

            font-weight: 400;

            margin: 6px 0;

            border-radius: 4px;

            font-size: 13px;

            font-style: italic;

        }/* Custom scrollbar for notification window */

        .notification-window::-webkit-scrollbar {

            width: 4px;

        }



        .notification-window::-webkit-scrollbar-track {

            background: rgba(248, 249, 250, 0.5);

        }



        .notification-window::-webkit-scrollbar-thumb {

            background: rgba(23, 162, 184, 0.3);

            border-radius: 2px;

        }



        .notification-window::-webkit-scrollbar-thumb:hover {

            background: rgba(23, 162, 184, 0.5);

        }






        
        .viewer-message {

            background: #ffc107;

            color: #212529;

            padding: 6px 12px;

            text-align: center;

            font-weight: 400;

            margin: 6px 0;

            border-radius: 4px;

            font-size: 13px;

            font-style: italic;

        }/* Two Column Layout */

        .main-content {

            display: flex;

            gap: 20px;

            margin-bottom: 20px;

            padding: 0 20px;

        }



        .left-column {

            flex: 1;

            min-width: 0;

        }



        .right-column {

            width: 300px;

            flex-shrink: 0;

        }

        
        
        /* NEW 3-COLUMN LAYOUT - FORCE HORIZONTAL */

        .main-content-3col {

            display: flex !important;

            flex-direction: row !important;

            gap: 20px !important;

            padding: 20px;

            align-items: flex-start !important;

            width: 100% !important;

            box-sizing: border-box !important;

        }

        
        
        .left-column.buttons-column {

            width: 250px !important;

            flex-shrink: 0 !important;

            display: flex !important;

            flex-direction: column !important;

            gap: 5px;

        }

        
        
        .center-column.title-banner-column {

            flex: 1 !important;

            text-align: center !important;

        }
        
        

        /* Checkout Status Banner - unified light blue */
        div#checkoutStatus.checkout-status {

            background: #bfdbfe !important;
            color: #1e40af !important;
            padding: 6px 11px !important;
            text-align: center !important;

            font-weight: 500 !important;

            margin: 8px 0 !important;

            border-radius: 4px !important;

            font-size: 18px !important;

            display: block !important;

        }
        
        

        /* Checked out state - unified medium blue */
        div#checkoutStatus.checkout-status.checked-out {

            background: #3b82f6 !important;
        }
        
        /* User display styling - copied from Word add-in */
        .current-user {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 8px;
        }
        
        .user-label {
            font-weight: 600;
            color: #856404;
        }
        
        .user-name {
            font-weight: bold;
            color: #495057;
            font-size: 12px;
        }
        
        .user-role {
            background: #fd7e14;
            color: white;
            padding: 1px 6px;
            border-radius: 8px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
        }
        
        .user-role.viewer {
            background: #dc3545;
        }

        
        
        .main-content-3col .right-column {

            width: 300px !important;

            flex-shrink: 0 !important;

        }

        /* Stretch columns to bottom */

        .main-content-3col { align-items: flex-start !important; }

        .right-column { position: sticky; top: 10px; align-self: flex-start; height: calc(100vh - 200px); display: flex; flex-direction: column; }

        .notification-window { flex: 1 1 auto; overflow: auto; }

        /* Narrow SuperDoc container for Word-like view */

        #superdoc { max-width: 820px !important; margin-left: auto !important; margin-right: auto !important; display:flex; justify-content:center; }

        .viewer-container { display:flex; justify-content:center; }

        /* Constrain internal SuperDoc wrapper and document (high specificity) */

        #superdoc .superdoc,

        #superdoc .superdoc__layers,

        #superdoc .superdoc__document,

        #superdoc .document,

        #superdoc .superdoc__sub-document,

        #superdoc .sub-document,

        #superdoc .pages,

        #superdoc .page,

        #superdoc .super-editor-container,

        #superdoc .super-editor {

            max-width: 820px !important;

            margin-left: auto !important;

            margin-right: auto !important;

            width: 100% !important;

        }

        #superdoc .superdoc__layers, #superdoc .layers { justify-content: center !important; }

        /* Also clamp helper layers */

        #superdoc .superdoc__selection-layer,

        #superdoc .comments-container,

        #superdoc .superdoc__comments-layer,

        #superdoc .comments-layer,

        #superdoc .ai-highlight-container,

        #superdoc .ai-highlight-layer {

            max-width: 820px !important;

            margin-left: auto !important;

            margin-right: auto !important;

            width: 100% !important;

        }

        /* FINAL: make the .superdoc root itself NOT stretch full-bleed */

        #superdoc .superdoc {

            width: auto !important;

            max-width: 820px !important;

            display: block !important;

            margin-left: auto !important;

            margin-right: auto !important;

        }

        .main-content-3col { min-height: calc(100vh - 140px); }

        /* Simple dropdown styles */

        .dropdown { position: relative; display: inline-block; }

        .dropdown-menu {

            display: none;

            position: absolute;

            right: 0;

            background: #fff;

            min-width: 220px;

            box-shadow: 0 2px 8px rgba(0,0,0,0.15);

            border-radius: 6px;

            padding: 6px;

            z-index: 1000;

        }

        .dropdown-menu button { width: 100%; text-align: left; }

        /* Unified button styling (low-saturation theme) */
        :root {

            --btn-primary: #6c7db8;        /* muted blue */
            --btn-primary-hover: #5a6ba1;  /* darker blue */
            --btn-secondary: #8a8db5;      /* muted purple */
            --btn-secondary-hover: #7a7da8; /* darker purple */
            --btn-neutral: #9ca3af;        /* light grey */
            --btn-neutral-hover: #6b7280;  /* darker grey */
        }
        /* === Shared dropdown component styles === */
        .shared-dropdown {
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 14px;
            background: white;
            color: var(--text-primary);
            min-width: 160px;
            transition: border-color 0.2s ease;
        }
        
        .shared-dropdown:hover {
            border-color: #6b7280;
        }
        
        .shared-dropdown:focus {
            outline: none;
            border-color: #6b7280;
            box-shadow: 0 0 0 2px rgba(107, 114, 128, 0.15);
        }

        
        
        /* Apply to all buttons within the new grid and common button classes */

        /* Primary controls in grid (top-left/bottom-left) */

        .controls-grid .grid-actions > button,

        .controls-grid .grid-actions > .dropdown > button,

        button.btn, .btn, .button,

        .btn-open, .btn-secondary, .btn-vendor, .btn-view-latest,

        .doc-action {

            background: var(--btn-primary) !important;
            color: #ffffff !important;

            border: none !important;

            padding: 10px 16px !important;

            border-radius: 8px !important;

            font-size: 14px !important;

            font-weight: 600 !important;

            cursor: pointer !important;

            transition: background-color .2s ease !important;

            min-height: 36px !important;

            min-width: 140px !important;

            display: inline-flex !important;

            align-items: center !important;

            justify-content: center !important;

            box-shadow: none !important;

            outline: none !important;

        }

        .controls-grid .grid-actions > button:hover,

        .controls-grid .grid-actions > .dropdown > button:hover,

        .btn:hover, .button:hover,

        .dropdown-menu button:hover, .btn-open:hover, .btn-secondary:hover, .btn-vendor:hover,

        .doc-action:hover { background: var(--btn-primary-hover) !important; }


        /* Dropdown menu items: secondary theme, uniform sizing */
        .controls-grid .dropdown .dropdown-menu button,

        .controls-grid .dropdown .dropdown-menu .doc-action {

            background: var(--btn-secondary) !important;
            color: #ffffff !important;

            border: none !important;

            padding: 10px 16px !important;

            border-radius: 8px !important;

            font-size: 14px !important;

            font-weight: 600 !important;

            min-height: 36px !important;

            min-width: 140px !important;

            display: block !important;

            text-align: left !important;

            box-shadow: none !important;

        }

        .controls-grid .dropdown .dropdown-menu button:hover,

        .controls-grid .dropdown .dropdown-menu .doc-action:hover { background: var(--btn-secondary-hover) !important; }


        /* Plain style for approvals table action buttons (match add-in) */

        #usersInlineContainer table button.btn {

            background: #f8f9fa !important;

            color: #212529 !important;

            border: 1px solid #ced4da !important;

            padding: 6px 10px !important;

            border-radius: 4px !important;

            font-size: 12px !important;

            font-weight: 500 !important;

            min-height: unset !important;

            min-width: unset !important;

            box-shadow: none !important;

        }

        #usersInlineContainer table button.btn[disabled] {

            opacity: .5 !important;

            cursor: default !important;

        }

        
        /* Modal approval buttons - now styled via inline JS for maximum specificity */
        
        /* Take Me Back to OpenGov button hover effect */
        .btn-back-to-opengov:hover {
            background: #e9d5ff !important;
            border-color: black !important;
            color: white !important;
        }
        /* Vendor modal explicit button styles to ensure visibility */
        #vendorModal .notification-modal-body button[type="button"] {
            background: #ffffff !important;
            color: #111 !important;
            border: 1px solid #cbd5e1 !important; /* slate-300 */
            border-radius: 4px !important;
        }
        #vendorModal .notification-modal-body button[type="submit"] {
            background: #0078d4 !important; /* OG blue */
            color: #ffffff !important;
            border: 1px solid #005ea2 !important; /* darker blue border */
            border-radius: 4px !important;
        }
        #vendorModal .notification-modal-body button[type="button"]:hover {
            background: #f8fafc !important;
            border-color: #94a3b8 !important; /* slate-400 */
        }
        #vendorModal .notification-modal-body button[type="submit"]:hover {
            background: #006cbe !important;
            border-color: #00518c !important;
        }
    </style>

    <script>
        // ===== CHAT (SHELL) =====
        (function setupChat(){
            try {
                const messagesEl = document.getElementById('chatMessages');
                const inputEl = document.getElementById('chatInput');
                const sendBtn = document.getElementById('chatSend');
                if (!messagesEl || !inputEl || !sendBtn) return;
                function appendMessage(text, role){
                    const row = document.createElement('div');
                    row.style.margin = '6px 0';
                    row.style.display = 'flex';
                    row.style.gap = '8px';
                    row.style.alignItems = 'flex-start';
                    const bubble = document.createElement('div');
                    bubble.style.padding = '8px 10px';
                    bubble.style.borderRadius = '10px';
                    bubble.style.maxWidth = '80%';
                    bubble.style.whiteSpace = 'pre-wrap';
                    bubble.style.fontSize = '13px';
                    if (role === 'user') { bubble.style.background = '#e7f1ff'; bubble.style.marginLeft = 'auto'; }
                    else { bubble.style.background = '#f8f9fa'; bubble.style.marginRight = 'auto'; }
                    bubble.textContent = text;
                    row.appendChild(bubble);
                    messagesEl.appendChild(row);
                    try { messagesEl.scrollTop = messagesEl.scrollHeight; } catch(_) {}
                }
                function send(){
                    const text = (inputEl.value || '').trim();
                    if (!text) return;
                    // remove placeholder if present
                    try { const ph = messagesEl.querySelector('div[style*="opacity"]'); if (ph) ph.remove(); } catch(_) {}
                    appendMessage(text, 'user');
                    inputEl.value = '';
                    // show typing indicator
                    const typing = document.createElement('div');
                    typing.id = 'chatTyping';
                    typing.style.margin = '6px 0';
                    typing.style.color = '#6c757d';
                    typing.style.fontSize = '12px';
                    typing.textContent = 'Assistant is typing…';
                    messagesEl.appendChild(typing);
                    try { messagesEl.scrollTop = messagesEl.scrollHeight; } catch(_) {}
                    // simulate bot reply
                    setTimeout(() => {
                        try { typing.remove(); } catch(_) {}
                        const words = ['Certainly','Interesting','Let\'s','consider','that','approach','briefly','then','continue','forward'];
                        const reply = Array.from({length: Math.floor(Math.random()*8)+3}, () => words[Math.floor(Math.random()*words.length)]).join(' ') + '.';
                        appendMessage(reply, 'bot');
                    }, 700 + Math.random()*900);
                }
                sendBtn.addEventListener('click', send);
                inputEl.addEventListener('keydown', (e)=>{ if(e.key==='Enter' && !e.shiftKey){ e.preventDefault(); send(); }});
                window.__chat = { appendMessage };
            } catch(_) {}
        })();

        // Work around SuperDoc UMD builds referencing a global __IS_DEBUG__

        // Ensure it exists before the library initializes to prevent ReferenceError

        window.__IS_DEBUG__ = false;

    </script>

    

    <script src="./new-feature-banner.js"></script>

</head>

<body>

    <div class="opengov-header">

        <div class="coming-soon-badge" id="comingSoonBadge">Coming 2026</div>

        <div class="opengov-logo">

            <img src="assets/opengov-logo.png" alt="OpenGov" style="height: 60px; width: auto;">

        </div>

        <div class="opengov-text">

            <h1 class="main-title">Redline Like You Mean It: The Future of Contracting</h1>

        </div>

    </div>



    <!-- User Controls -->
    <!-- legacy user-controls block hidden; controls live in grid below -->

    <div class="user-controls" style="display:none"></div>



    <!-- PRE-EDITOR 2x2 GRID LAYOUT -->

    <script>

        window.getWebCurrentDocId = async function getWebCurrentDocId() {
        try {
            const doc = await fetch('http://localhost:3001/api/current-document', { cache: 'no-store' }).then(r => r.json());
            return (doc && (doc.id || doc.documentId)) ? (doc.id || doc.documentId) : 'doc-current';
        } catch {
            return 'doc-current';
        }
        };

        // Initialize New Feature Banner for web

        if (typeof window.initNewFeatureBanner === 'function') {

            window.initNewFeatureBanner('web');

        }

        
        
        // Load shared approvals UI config

        window.__approvalsUi = null;

        (async function loadApprovalsUi(){

            const candidates = ['approvals-ui.json', '/approvals-ui.json', '/scripts/approvals-ui.json'];

            for (const url of candidates) {

                try {

                    const resp = await fetch(url);

                    if (resp.ok) { window.__approvalsUi = await resp.json(); break; }

                } catch(_) {}

            }

        })();



        // Helper to refresh web document actions dropdown from matrix

        function refreshWebActionsFromMatrix() {

            if (window.__lastStateMatrix && typeof window.refreshActionsDropdownFromMatrix === 'function') {

                window.refreshActionsDropdownFromMatrix('webDocActionsSelect', window.__lastStateMatrix);

            }

        }

    </script>

    <style>

        .controls-grid { display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: auto auto; gap: 12px; padding: 0 20px; }

        .grid-card { background: #ffffff; border: 1px solid #e9ecef; border-radius: 8px; padding: 10px; }

        .grid-title { font-weight: 600; margin-bottom: 6px; color: #495057; font-size: 13px; }

        .grid-actions { display: flex; gap: 6px; flex-wrap: wrap; }

        /* Normalize button baseline */

        .grid-actions * { box-sizing: border-box; }

        .grid-notifications { grid-column: 2; grid-row: 1 / span 2; display: flex; flex-direction: column; }

        .status-bar { font-size: 14px; margin-bottom: 6px; color: #495057; }

        .title-banner-stack { padding: 0.8px 20px 0 20px; }
        .title-banner-stack .document-title { margin: 4px 0 6px 0; font-weight: 600; font-size: 16px; color: #343a40; text-align:center; }

        .title-banner-stack #viewerMessage { margin: 0 0 6px 0; }

        .title-banner-stack #checkoutStatus { margin: 0 0 10px 0; text-align:center; }

    </style>



    <script>

        // Load theme from server and set CSS variables

        (async function applyServerTheme(){

            try {

                const r = await fetch('http://localhost:3001/api/theme');

                const j = await r.json();

                const c = j && j.theme && j.theme.colors;

                if (!c) return;

                const root = document.documentElement;

                Object.entries({

                    '--bg-surface': c.bgSurface,

                    '--bg-muted': c.bgMuted,

                    '--text-primary': c.textPrimary,

                    '--text-muted': c.textMuted,

                    '--border': c.border,

                    '--accent': c.accent,

                    '--status-bg': c.statusBg,

                    '--status-text': c.statusText,

                    '--pill-blue-bg': c.pillBg,

                    '--pill-blue-text': c.pillText,

                    '--viewer-bg': c.viewerBg,

                    '--viewer-text': c.viewerText

                }).forEach(([k,v]) => { if (v) root.style.setProperty(k, v); });

            } catch(_) {}

        })();

    </script>



    <!-- Title + banners above the two-column grid -->

    <div class="title-banner-stack">

        
        <p class="document-title" id="document-title" style="margin-bottom:6px; text-align:center;">Title: No document loaded</p>

        <div id="viewerMessage" class="viewer-message" style="display: none;"></div>

        <div id="checkoutStatus" class="checkout-status" style="display: none;"></div>

        <div id="checkoutBanner" class="checkout-banner" style="display: none;"></div>

    </div>



    <div class="controls-grid">

        <!-- Left: Users + Actions -->

        <div class="grid-card" style="grid-column:1; grid-row:1; background:#fff3cd; border:1px solid #ffeaa7; border-radius:6px;">


            <div class="grid-actions" style="align-items:center; gap:8px; padding:8px;">

                <div class="current-user">
                    <span class="user-label">User:</span>
                    <span id="currentUserDisplay" class="user-name">Loading...</span>
                    <span id="currentUserRole" class="user-role">(editor)</span>
                    <span id="approvalsPillWeb" class="pill-blue" style="display:inline-block; padding:4px 10px; border-radius:999px; font-weight:600; font-size:12px; margin-left:8px;">—/— approved</span>
                    <button id="btnNotificationBell" title="Notifications" aria-label="Open notifications" onclick="openNotificationModal()" style="margin-left:8px; display:inline-flex; align-items:center; justify-content:center; width:28px; height:28px; border-radius:50%; border:1px solid #dee2e6; background:#fff; cursor:pointer; position:relative;">
                        <span style="font-size:14px;">🔔</span>
                        <span id="notificationBellBadge" style="display:none; position:absolute; top:-4px; right:-4px; background:#dc3545; color:#fff; border-radius:999px; padding:0 5px; font-size:10px; line-height:16px; min-width:16px; text-align:center;">0</span>
                    </button>
                </div>
                 <div class="section-body" style="display:flex; flex-direction:column; gap:8px;">
                     <div style="display:flex; align-items:center; gap:8px; margin-left:-3px;">
                         <label for="userSwitcher" style="width:120px;">Switch user:</label>
                         <select id="userSwitcher" class="shared-dropdown user-select" onchange="switchUser(this.value)" style="width:200px;">
                            <option value="">no change</option>
                </select>
                        <button id="templatesBtnWeb" onclick="openTemplatesModal()" class="shared-dropdown" style="margin-left:8px; cursor:pointer; background:#fff !important; color:#111 !important; border:1px solid #dee2e6 !important; border-radius:6px !important; padding:8px 12px !important; display:inline-flex; align-items:center; justify-content:flex-start; text-align:left; width:200px;">Templates</button>
            </div>
                     <div style="display:flex; align-items:center; gap:8px;">
                         <label for="webDocActionsSelect" style="width:115px;">Document actions:</label>
                         <select id="webDocActionsSelect" class="shared-dropdown user-select" style="width:200px; margin-left:5px;" onfocus="refreshWebDropdownFromMatrix()" onchange="onWebDocActionChange(this.value)">
                             <option value="">select</option>
                             <option value="compile">Compile</option>
                         </select>
                         <button id="backToOpenGovBtn" class="shared-dropdown" onclick="window.openOpenGovModal && window.openOpenGovModal();" style="margin-left:8px; cursor:pointer; background:#fff !important; color:#111 !important; border:1px solid #dee2e6 !important; border-radius:6px !important; padding:8px 12px !important; display:inline-flex; align-items:center; justify-content:flex-start; text-align:left; width:200px;">Take Me Back to OpenGov</button>
                     </div>
                 </div>
             </div>

            <div id="docActionsDropdown_grid" class="dropdown" style="display:none;"></div>

        </div>



        <!-- Right: Chat (span 2 rows) -->
        <div class="grid-card" style="grid-column:2; grid-row:1 / span 2; display:flex; flex-direction:column;">
            <div style="display:flex; align-items:center; justify-content:space-between; padding:6px 10px; border-bottom:1px solid #e9ecef;">
                <div class="grid-title" style="margin:0;">💬 Chat</div>
                <div style="font-size:11px; color:#6c757d;">experimental</div>
            </div>
            <div id="chatPanel" style="display:flex; flex-direction:column; gap:8px; padding:10px; height:100%;">
                <div id="chatMessages" style="flex:1 1 auto; overflow:auto; border:1px solid #e9ecef; border-radius:6px; padding:10px; background:#fff;">
                    <div style="opacity:.6; font-size:12px;">No messages yet</div>
                </div>
                <div style="display:flex; gap:8px; align-items:flex-start;">
                    <textarea id="chatInput" rows="2" placeholder="Type a message..." style="flex:1 1 auto; resize:vertical; border:1px solid #dee2e6; border-radius:6px; padding:8px; font-size:13px;"></textarea>
                    <button id="chatSend" class="shared-dropdown" style="min-width:90px;">Send</button>
                </div>
            </div>
        </div>

    </div>



    <!-- CLEAN 3-COLUMN LAYOUT (legacy center banners removed; single source above) -->

    <div class="main-content-3col" style="display: flex !important; flex-direction: row !important; gap: 20px; padding: 20px; align-items: flex-start !important; width: 100% !important; box-sizing: border-box !important;">

        <div class="left-column buttons-column" style="width: 0 !important; flex-shrink: 0 !important; display: flex !important; flex-direction: column !important; gap: 5px;"></div>

        <div class="right-column" style="display:none;"></div>

    </div>






    
    <!-- Hidden file input -->

    <input type="file" id="fileInput" accept=".docx,.doc" style="display: none;" onchange="handleFileSelect(event)">



    <div class="viewer-container">

        <div id="superdoc-toolbar"></div>



        <div id="superdoc">

            <div class="empty-state">

                <h2>Welcome to OpenGov Contract Redlining</h2>

                <p>Real-time collaboration and redlining - the future of contracting!</p>

                <p>Ready for document collaboration workflow.</p>

            </div>

        </div>

    </div>

    <!-- COMPILE modal (full) -->
    <div id="compileModal" style="display:none; position:fixed; inset:0; z-index:2147483647;">
        <div onclick="closeCompileModal()" style="position:absolute; inset:0; background: rgba(0,0,0,0.35);"></div>
        <div style="position:absolute; top:50%; left:50%; transform: translate(-50%, -50%); background:#fff; border-radius:10px; width:min(640px, 92vw); max-height:80vh; overflow:auto; padding:16px; box-shadow:0 8px 24px rgba(0,0,0,0.25);">
            <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:10px;">
                <div style="font-size:16px; font-weight:600;">Compile</div>
            </div>
            <div id="compileBodyWeb"></div>
        </div>
    </div>



    <!-- Notification Modal -->

    <div id="notificationModal" class="notification-modal" style="display: none;">

        <div class="notification-modal-backdrop" onclick="closeNotificationModal()"></div>

        <div class="notification-modal-content">

            <div class="notification-modal-header">

                <h3 class="notification-modal-title">🔔 Notifications</h3>

                <button class="notification-modal-close" onclick="closeNotificationModal()">×</button>

            </div>

            <div class="notification-modal-body" id="notificationModalBody">

                <div class="no-notifications">

                    No notifications yet

                </div>

            </div>

        </div>

    </div>



    <!-- Send to Vendor Modal -->

    <div id="vendorModal" class="notification-modal" style="display: none;">

        <div class="notification-modal-backdrop" onclick="closeVendorModal()"></div>

        <div class="notification-modal-content">

            <div class="notification-modal-header">

                <h3 class="notification-modal-title">📤 Send to Vendor</h3>

                <button class="notification-modal-close" onclick="closeVendorModal()">×</button>

                </div>

            <div class="notification-modal-body" style="max-height:70vh; overflow:auto;">

                <form id="vendorForm" onsubmit="sendToVendor(event)">

                    <div style="margin-bottom: 15px;">

                        <label style="display: block; margin-bottom: 5px; font-weight: 600;">Vendor:</label>

                        <input type="text" id="vendorCompany" value="Moti's Builders" readonly 

                               style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; background: #f5f5f5;">

                </div>

                    <div style="margin-bottom: 15px;">

                        <label style="display: block; margin-bottom: 5px; font-weight: 600;">Contact Name:</label>

                        <input type="text" id="vendorName" value="Hoo R. U" required

                               style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">

                </div>

                    <div style="margin-bottom: 15px;">

                        <label style="display: block; margin-bottom: 5px; font-weight: 600;">Email:</label>

                        <input type="email" id="vendorEmail" value="moti@real.builders" required

                               style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">

                </div>

                    <div style="margin-bottom: 20px;">

                        <label style="display: block; margin-bottom: 5px; font-weight: 600;">Notes (optional):</label>

                        <textarea id="vendorNotes" placeholder="Add any notes or instructions for the vendor..."

                               style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; resize: vertical; min-height: 80px; font-family: inherit;"></textarea>

                </div>

                    <div style="position:sticky; bottom:0; background:#fff; padding-top:10px; display: flex; gap: 10px; justify-content: flex-end; border-top: 1px solid #e5e7eb; z-index:2;">

                        <button type="button" onclick="closeVendorModal()" 

                                style="padding: 8px 16px !important; border: 1px solid #cbd5e1 !important; background: #ffffff !important; color:#111 !important; border-radius: 4px !important; cursor: pointer !important;">

                            Cancel

                        </button>

                        <button type="submit" 

                                style="padding: 8px 16px !important; border: 1px solid #005ea2 !important; background: #0078d4 !important; color: #ffffff !important; border-radius: 4px !important; cursor: pointer !important;">

                            Send to Vendor

                        </button>

                </div>

                </form>

            </div>

    </div>



    <!-- Vendor Confirmation Modal -->

    <div id="vendorConfirmationModal" class="notification-modal" style="display: none;">

        <div class="notification-modal-backdrop" onclick="closeVendorConfirmationModal()"></div>

        <div class="notification-modal-content">

            <div class="notification-modal-header">

                <h3 class="notification-modal-title">✅ Confirmation</h3>

                <button class="notification-modal-close" onclick="closeVendorConfirmationModal()">×</button>

            </div>

            <div class="notification-modal-body">

                <p style="text-align: center; font-size: 16px; margin: 20px 0;">Your vendor has been emailed</p>

                <div style="display: flex; justify-content: center;">

                    <button onclick="closeVendorConfirmationModal()" 

                            style="padding: 10px 20px; background: #0078d4; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">

                        OK

                    </button>

                </div>

            </div>

        </div>

    </div>



    <!-- Users Modal -->

    <div id="usersModal" class="notification-modal" style="display:none;">

        <div class="notification-modal-backdrop" onclick="closeUsersModal()"></div>

        <div class="notification-modal-content" style="max-width:700px; width:90%;">

            <div class="notification-modal-header">

                <h3 class="notification-modal-title">👥 Users</h3>

                <button class="notification-modal-close" onclick="closeUsersModal()">×</button>

            </div>

            <div class="notification-modal-body">

                <div id="usersModalBody">

                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">

                        <div style="font-weight:600;">Approval details</div>

                        <button class="btn btn-secondary" onclick="refreshUsersModal()">Refresh</button>

                    </div>

                    <div style="overflow:auto; max-height:50vh; border:1px solid #e9ecef; border-radius:6px;">

                        <table style="width:100%; border-collapse:collapse; font-size:14px;">

                            <thead style="position:sticky; top:0; background:#f8f9fa;">

                                <tr id="approvalsHeaderRowWeb">

                                    <th style="text-align:left; padding:8px; border-bottom:1px solid #e9ecef;" data-col="user">User</th>

                                    <th style="text-align:left; padding:8px; border-bottom:1px solid #e9ecef;" data-col="role">Role</th>

                                    <th style="text-align:left; padding:8px; border-bottom:1px solid #e9ecef; width:110px;" data-col="status">Approved</th>

                                    <th style="text-align:left; padding:8px; border-bottom:1px solid #e9ecef;" data-col="actions">Action</th>

                                </tr>

                            </thead>

                            <tbody id="usersTableBody"></tbody>

                        </table>

                    </div>

                </div>

            </div>

        </div>

    </div>



    <!-- Load SuperDoc from local node_modules -->

    <script>

        window.testModeToggle = function() {

            console.log(" TESTING MODE TOGGLE...");

            const role = getCurrentUserRole();

            const superdoc = window.currentSuperdoc;

            const toolbar = document.querySelector("#superdoc-toolbar");

            console.log("Role:", role, "Expected:", getSuperdocMode(role));

            console.log("SuperDoc Mode:", superdoc && superdoc.getMode ? superdoc.getMode() : (superdoc && superdoc.mode ? superdoc.mode : "unknown"));

            console.log("Toolbar:", !!toolbar);

            return { role, expectedMode: getSuperdocMode(role), currentMode: superdoc ? superdoc.getDocumentMode() : "none" };

        };

    </script>

    <script src="./node_modules/@harbour-enterprises/superdoc/dist/superdoc.umd.js"></script>

    <script>

        // SuperDoc variables

        let currentSuperdoc = null;

        let currentDocumentId = null;

         
        
        // Notification system variables

        let notificationHistory = [];

        let hasUnreadNotifications = false;

        let notificationIdCounter = 0;



        // Debug SuperDoc loading

        console.log('SuperDoc available:', typeof SuperDoc);

        console.log('SuperDocLibrary available:', typeof SuperDocLibrary);

        console.log('SuperDocLibrary.SuperDoc available:', typeof SuperDocLibrary?.SuperDoc);



        // SSE connection

        let eventSource = null;

         
        
        function connectSSE() {

            try {

                const clientId = 'web-' + Date.now() + '-' + Math.random().toString(36).slice(2);

                window.__clientId = clientId;

                eventSource = new EventSource(`http://localhost:3001/api/events?platform=web&clientId=${clientId}`);

                 
                
                eventSource.onopen = function(event) {

                    console.log('SSE connection opened');

                    console.log('📡 Connected to real-time events');

                     // Unified initial load when SSE connects
                     setTimeout(() => { try { fetchUnifiedStateWeb(); loadInitialApprovalsData(); } catch(_) {} }, 300);
                };

                 
                
                eventSource.onmessage = function(event) {

                    const data = JSON.parse(event.data);

                    console.log('SSE event received:', data);
                    
                     
                    
                    if (data.type === 'connected') {

                        console.log(`📡 SSE: ${data.message}`);
                        try { addNotification(data.message || 'Connected to real-time events', 'info'); } catch(_) {}

                    } else if (data.type === 'document-checked-out') {

                        console.log(`📡 SSE: ${data.message}`);

                        try { addNotification(data.message || 'Document checked out', 'info'); } catch(_) {}
                         fetchDocumentStatus().then(() => updateUIFromStateMatrix('web', getCurrentUser, getCurrentUserRole, currentDocumentState)); // Refresh UI when checkout state changes
                    } else if (data.type === 'document-checked-in') {

                        console.log(`📡 SSE: ${data.message}`);

                        try { addNotification(data.message || 'Document checked in', 'success'); } catch(_) {}
                         fetchDocumentStatus().then(() => updateUIFromStateMatrix('web', getCurrentUser, getCurrentUserRole, currentDocumentState)); // Refresh UI when checkout state changes
                    } else if (data.type === 'document-saved') {

                        console.log(`📡 SSE: ${data.message}`);

                        try { addNotification(data.message || 'Progress saved', 'info'); } catch(_) {}
                        // No need to refresh buttons for save progress (still checked out)

                    } else if (data.type === 'checkout-cancelled') {

                        console.log(`📡 SSE: ${data.message}`);

                        try { addNotification(data.message || 'Checkout cancelled', 'info'); } catch(_) {}
                         fetchDocumentStatus().then(() => updateUIFromStateMatrix('web', getCurrentUser, getCurrentUserRole, currentDocumentState)); // Refresh UI when checkout state changes
                    } else if (data.type === 'document-uploaded') {

                        console.log(`📡 SSE: ${data.message}`);

                        console.log(`📄 Auto-loading document: ${data.filename} (ID: ${data.documentId})`);

                        try { addNotification(data.message || `Document uploaded${data.filename ? ': ' + data.filename : ''}`, 'success'); } catch(_) {}

                         fetchDocumentStatus().then(() => updateUIFromStateMatrix('web', getCurrentUser, getCurrentUserRole, currentDocumentState)); // Refresh UI when new document is available
                    } else if (data.type === 'document-finalize-updated') {
                        console.log(`📡 SSE: Finalize updated → ${data.isFinal ? 'final' : 'draft'}`);
                        try { addNotification(data.isFinal ? 'Finalized. The first approver has been notified.' : 'Moved back to Draft.', data.isFinal ? 'success' : 'info'); } catch(_) {}
                        fetchDocumentStatus().then(() => updateUIFromStateMatrix('web', getCurrentUser, getCurrentUserRole, currentDocumentState));
                        // Auto-load the uploaded document

                        if (data.documentId && data.filename) {

                            console.log(`🚀 Calling loadSuperdoc(${data.documentId}, ${data.filename})`);

                            loadSuperdoc(data.documentId, data.filename);

                        } else {

                            console.warn('⚠️ Missing documentId or filename in SSE event:', data);

                        }

                    } else if (data.type === 'document-sent-to-vendor') {

                        console.log(`📡 SSE (ignored for state): ${data.message}`);

                        addNotification(data.message || 'Vendor has been invited to redline', 'info');

                    } else if (data.type === 'vendor-invited') {

                        console.log(`📡 SSE: ${data.message}`);

                        addNotification(data.message || 'Vendor has been invited to redline', 'info');

                    } else if (data.type === 'vendor-checkout-overridden') {

                        console.log(`📡 SSE: ${data.message}`);

                        try { addNotification(data.message || 'Vendor checkout overridden', 'info'); } catch(_) {}
                         fetchDocumentStatus().then(() => updateUIFromStateMatrix('web', getCurrentUser, getCurrentUserRole, currentDocumentState)); // Refresh UI when vendor checkout overridden
                    } else if (data.type === 'user-switched') {

                        console.log(`📡 WEB SSE: User switched event received:`, data);

                         
                        
                        // Only handle web platform user switches

                        if (data.platform === 'web') {

                            console.log(`📡 WEB: Processing web user switch to ${data.currentUser.name}`);
                            try { addNotification(`Web user switched to ${data.currentUser.name} (${data.currentUser.role})`, 'info'); } catch(_) {}

                        // Update current user if this was triggered by another client

                        if (data.currentUser.id !== currentUser?.id) {

                            currentUser = data.currentUser;

                                window.currentUser = data.currentUser;

                            updateCurrentUserDisplay();

                            populateUserSwitcher();

                                updateButtonVisibilityFromMatrix();

                                 
                                
                                // Reinitialize SuperDoc with new role-based mode

                                if ((currentSuperdoc || window.currentSuperdoc) && currentDocumentState.currentDocument) {

                                    console.log('🔄 SSE: Reinitializing SuperDoc for new web user role:', currentUser.role);

                                    loadSuperdoc(currentDocumentState.currentDocument);

                                }

                            }

                        } else {

                            console.log('WEB: Ignoring unknown user switch event');

                        }

                    } else if (data.type === 'approvals-updated' || data.type === 'approvals-list-updated' || data.type === 'approvals-notes-updated' || data.type === 'approvals-reminder-sent') {
                         console.log('📡 WEB SSE: approvals-change received:', data);
                         // Pill counts are authoritative from approvals/state; do not use SSE-provided counts to avoid drift
                         // Always re-pull unified snapshot to avoid drift and races
                         fetchUnifiedStateWeb();
                         // If approvals modal is open, refresh only for structural changes; skip on reminder to preserve inline feedback
                         if (data.type !== 'approvals-reminder-sent') {
                           (async () => {
                             try {
                               const modal = document.getElementById('approvalsModalWeb');
                               if (modal && getComputedStyle(modal).display !== 'none') {
                                 const actorId = await (typeof getWebActorId === 'function' ? getWebActorId() : null);
                                 let isEditor = false;
                                 try {
                                   const statusResp = await fetch('http://localhost:3001/api/status');
                                   const statusJson = await statusResp.json();
                                   isEditor = !!(statusJson && statusJson.platformUsers && statusJson.platformUsers.web && statusJson.platformUsers.web.role === 'editor');
                                 } catch(_) {}
                                 const currentId = (window.currentDocumentState && window.currentDocumentState.currentDocument && window.currentDocumentState.currentDocument.id) || 'default-doc';
                                 const st = await ApprovalsClient.getState({ documentId: currentId });
                                 if (typeof renderApprovalsTableWeb === 'function') {
                                   renderApprovalsTableWeb(st, { actorId, isEditor });
                                 }
                               }
                             } catch (e) { console.warn('Approvals modal refresh failed:', e); }
                           })();
                         }
                    } else if (data.type === 'permission-changed') {

                        console.log(`📡 SSE: Permission changed for ${data.user.name}`);

                        // Refresh button states if this affects current user

                        if (data.userId === currentUser?.id) {

                            // Update current user role

                            currentUser.role = data.role;

                            updateCurrentUserDisplay();

                            // Update state matrix after status change

                            updateButtonVisibilityFromMatrix();

                            try { refreshUsersModal(); } catch (e) { /* ignore */ }

                            addNotification(`Your access level changed to ${data.role}`, 'info');

                        }

                                try { refreshUsersModal(); } catch (e) { /* ignore */ }

                    }

                };

                 
                
                eventSource.onerror = function(event) {

                    console.error('SSE error:', event);

                    console.log('📡 Connection error - retrying...');

                };
                
                 
                
            } catch (error) {

                console.error('Failed to connect SSE:', error);

                console.log('📡 Failed to connect to events');

            }

        }

         
        
        // Document state

        let currentDocumentState = {

            isCheckedOut: false,

            checkedOutBy: null,

            currentDocument: null

        };

         
        
        // User management state

        let currentUser = null;

        let allUsers = [];

         
        
        // Simple fetch with timeout helper to avoid hanging UI

        async function fetchWithTimeout(url, options = {}, timeoutMs = 5000) {

            const controller = new AbortController();

            const id = setTimeout(() => controller.abort(), timeoutMs);

            try {

                const response = await fetch(url, { ...options, signal: controller.signal });

                return response;

            } finally {

                clearTimeout(id);

            }

        }



        // Initialize web-specific user system

        async function initializeUserSystem() {

            try {

                console.log('👤 WEB: Initializing independent web user system...');

                 
                
                // Load current web user

                const userResponse = await fetchWithTimeout('http://localhost:3001/api/user/web/current');

                if (userResponse.ok) {

                    const userData = await userResponse.json();

                    currentUser = userData.user;

                    window.currentUser = userData.user; // Also set global variable

                    updateCurrentUserDisplay();

                    console.log('👤 WEB: Current user loaded:', userData.user.name, `(${userData.user.role})`);

                }

                 
                
                // Load all web users for switcher

                const usersResponse = await fetchWithTimeout('http://localhost:3001/api/user/web/users');

                if (usersResponse.ok) {

                    const usersData = await usersResponse.json();

                    allUsers = usersData.users;

                } else {

                    allUsers = [];

                }

                    populateUserSwitcher();

                if (Array.isArray(allUsers) && allUsers.length) {

                    console.log('👤 WEB: Available users loaded:', allUsers.map(u => u.name));

                } else {

                    console.warn('👤 WEB: No users available');

                }

                 
                
                console.log('✅ WEB: Independent user system initialized successfully');
                
                 

                 // Use state matrix instead of legacy updateButtonStates
                 if (typeof window.updateUIFromStateMatrix === 'function') {
                     window.updateUIFromStateMatrix('web', getCurrentUser, getCurrentUserRole, currentDocumentState);
                 }
            } catch (error) {

                console.error('❌ WEB: Failed to initialize user system:', error);

                try { populateUserSwitcher(); } catch (e) {}

            }

        }

         
        
        // Update current user display

        function updateCurrentUserDisplay() {

            const nameElement = document.getElementById('currentUserDisplay');

            const roleElement = document.getElementById('currentUserRole');

             
            
            if (currentUser && nameElement && roleElement) {

                nameElement.textContent = currentUser.name;

                roleElement.textContent = `(${currentUser.role})`;

                roleElement.className = `user-role ${currentUser.role}`;

            }

        }

         
        
        // Populate user switcher dropdown

        function populateUserSwitcher() {

            const switcher = document.getElementById('userSwitcher');

            if (!switcher) return;

             
            
            switcher.innerHTML = '';


             // Add default "no change" option
             const defaultOption = document.createElement('option');
             defaultOption.value = '';
             defaultOption.textContent = 'no change';
             switcher.appendChild(defaultOption);


            if (!Array.isArray(allUsers) || allUsers.length === 0) {

                return;

            }

             
            
            allUsers.forEach(user => {

                const option = document.createElement('option');

                option.value = user.id;

                option.textContent = `${user.name} (${user.role})`;

                option.selected = currentUser && user.id === currentUser.id;

                switcher.appendChild(option);

            });

        }

         
        
        // Switch web user (platform-specific demo function)

        async function switchUser(userId) {

            if (!userId) return;

             
            
            try {

                console.log('👤 WEB: Switching to user:', userId);

                 
                
                const response = await fetch('http://localhost:3001/api/user/web/switch', {

                    method: 'POST',

                    headers: { 'Content-Type': 'application/json' },

                    body: JSON.stringify({ userId })

                });

                 
                
                if (response.ok) {

                    const data = await response.json();

                    currentUser = data.user;

                    window.currentUser = data.user; // Also update global variable

                    updateCurrentUserDisplay();

                     
                    
                    // Update button states based on new user role

                    updateButtonVisibilityFromMatrix();

                     

                    try { await refreshUsersModal(); } catch (e) { /* ignore */ }

                     
                    
                    // Reinitialize SuperDoc with new role-based mode

                    console.log('🔍 DEBUG: currentSuperdoc exists:', !!currentSuperdoc);

                    console.log('🔍 DEBUG: window.currentSuperdoc exists:', !!window.currentSuperdoc);

                    console.log('🔍 DEBUG: currentDocumentState.currentDocument exists:', !!currentDocumentState.currentDocument);

                     
                    
                    if ((currentSuperdoc || window.currentSuperdoc) && currentDocumentState.currentDocument) {

                        console.log('🔄 Reinitializing SuperDoc for new role:', currentUser.role);

                        console.log('🔄 Current document:', currentDocumentState.currentDocument);

                        await loadSuperdoc(currentDocumentState.currentDocument);

                        try { await refreshUsersModal(); } catch (e) { /* ignore */ }

                    } else {

                        console.log('❌ Cannot reinitialize SuperDoc - missing conditions');

                        console.log('  currentSuperdoc:', !!currentSuperdoc);

                        console.log('  window.currentSuperdoc:', !!window.currentSuperdoc);

                        console.log('  currentDocumentState.currentDocument:', !!currentDocumentState.currentDocument);

                    }

                     
                    
                    // Add notification

                    addNotification(`Web user switched to ${currentUser.name} (${currentUser.role})`, 'info');

                     
                    
                    console.log('✅ WEB: User switched to:', currentUser.name, `(${currentUser.role})`);

                } else {

                    const error = await response.json();

                    console.error('❌ WEB: Failed to switch user:', error);

                    addNotification('Failed to switch web user', 'error');

                }

            } catch (error) {

                console.error('❌ WEB: Error switching user:', error);

                addNotification('Error switching web user', 'error');

            }

        }

         
        
        // Role validation

        const VALID_ROLES = ['editor', 'viewer', 'suggester', 'vendor'];

        function validateRole(role) {

            return VALID_ROLES.includes(role);

        }

         
        
        // Get current user role for permission checks

        function getCurrentUser() {

            return currentUser;

        }



        function getCurrentUserRole() {

            const role = window.currentUser?.role || 'viewer'; // Default to viewer

            return validateRole(role) ? role : 'viewer'; // Ensure role is valid

        }



        // SuperDoc mode mapping - maps user roles to SuperDoc document modes

        function getSuperdocMode(userRole) {

            switch(userRole) {

                case 'suggester': return 'suggesting'; // Use suggesting mode for suggesters

                case 'vendor': return 'suggesting'; // Use suggesting mode for vendors  

                case 'editor': return 'editing';

                case 'viewer': return 'viewing';

                default: return 'viewing'; // Safe default

            }

        }

         
        
        // Map user role to SuperDoc userRole property

        function getSuperdocUserRole(userRole) {

            switch(userRole) {

                case 'suggester': return 'suggester';

                case 'vendor': return 'suggester'; // Vendors act as suggesters in SuperDoc

                case 'editor': return 'editor';

                case 'viewer': return 'viewer';

                default: return 'viewer'; // Safe default

            }

        }

         
        
        // Check if current user can edit

        function canCurrentUserEdit() {

            const role = getCurrentUserRole();

            return role === 'editor' || role === 'suggester' || role === 'vendor';

        }



        // User selection is always enabled - no locking mechanism

         
        
        // ========================================

        // TESTING FUNCTIONS

        // ========================================

         
        
        // Test user switching

        function testUserSystem() {

            console.log('🧪 Testing user system...');

            console.log('Current user:', currentUser);

            console.log('All users:', allUsers);

            console.log('Can edit:', canCurrentUserEdit());

             
            
            // Test notifications

            addNotification('User system test - switching to Sarah (viewer)', 'info');

             
            
            return {

                currentUser,

                allUsers,

                canEdit: canCurrentUserEdit(),

                userRole: getCurrentUserRole()

            };

        }

         
        
        // Debug function to check user state

        function debugUserState() {

            return {

                currentUser,

                allUsers,

                canEdit: canCurrentUserEdit(),

                role: getCurrentUserRole(),

                buttonStates: getVisibleButtons()

            };

        }

         
        
        // Debug web viewer state

        function debugWebViewerState() {

            const viewerContainer = document.querySelector('.viewer-container');

            return {

                currentUser,

                canEdit: canCurrentUserEdit(),

                role: getCurrentUserRole(),

                viewerContainer: viewerContainer ? {

                    classList: Array.from(viewerContainer.classList),

                    hasReadOnlyMode: viewerContainer.classList.contains('read-only-mode'),

                    hasEditMode: viewerContainer.classList.contains('edit-mode')

                } : null,

                buttonStates: getVisibleButtons()

            };

        }



        // DEBUG: Test web viewer protection layers

        window.debugWebProtectionLayers = () => {

            console.log('🧪 WEB: TESTING MULTI-LAYER PROTECTION DETECTION');

            console.log('='.repeat(50));

             
            
            const accessInfo = determineWebViewerAccess();

             
            
            console.log('📊 WEB: COMPLETE ACCESS ANALYSIS:');

            console.log('   Final Result:', accessInfo.canEdit ? '✅ CAN EDIT' : '❌ READ-ONLY');

            console.log('   Reason:', accessInfo.reason);

            console.log('');

            console.log('🔍 WEB: LAYER BREAKDOWN:');

            console.log('   📄 File Level:');

            console.log('      Detected:', accessInfo.layers.fileLevel.detected ? '✅' : '❌ (web limitation)');

            console.log('      Read-Only:', accessInfo.layers.fileLevel.readOnly ? '🔒' : '✏️ (unknown)');

            console.log('   👤 User Level:');

            console.log('      Role:', accessInfo.layers.userLevel.role);

            console.log('      Can Edit:', accessInfo.layers.userLevel.canEdit ? '✅' : '❌');

            console.log('   🤝 Collaboration Level:');

            console.log('      Available:', accessInfo.layers.collaborationLevel.available ? '✅' : '❌');

            console.log('      Checked Out By:', accessInfo.layers.collaborationLevel.checkedOutBy || 'none');

             
            
            return accessInfo;

        };



        // DEBUG: Test web viewer visual feedback system

        window.debugWebVisualFeedback = () => {

            console.log('🎨 WEB: TESTING VISUAL FEEDBACK SYSTEM');

            console.log('='.repeat(50));

             
            
            const accessInfo = determineWebViewerAccess();

             
            
            console.log('🔍 WEB: Access Info:', {

                canEdit: accessInfo.canEdit,

                reason: accessInfo.reason,

                layers: accessInfo.layers

            });

             
            
            console.log('🎨 WEB: Applying visual feedback...');

            updateWebUIForAccessLevel(accessInfo);

             
            
            // Check applied CSS classes

            const viewerContainer = document.querySelector('.viewer-container');

             
            
            console.log('📋 WEB: Applied CSS Classes:');

            console.log('   Viewer Container classes:', viewerContainer ? Array.from(viewerContainer.classList) : 'not found');

             
            
            // Check button visibility

            const visibleButtons = [];

            const hiddenButtons = [];

             
            
            ['checkoutBtn', 'sendVendorBtn', 'overrideVendorBtn', 'saveProgressBtn', 'checkinBtn', 'cancelBtn', 'openBtn', 'viewOnlyBtn'].forEach(id => {

                const btn = document.getElementById(id);

                if (btn) {

                    if (btn.style.display === 'none') {

                        hiddenButtons.push(id);

                    } else {

                        visibleButtons.push(id);

                    }

                }

            });

             
            
            console.log('🔘 WEB: Button States:');

            console.log('   Visible:', visibleButtons);

            console.log('   Hidden:', hiddenButtons);

             
            
            return {

                accessInfo,

                cssClasses: {

                    viewerContainer: viewerContainer ? Array.from(viewerContainer.classList) : []

                },

                buttons: { visible: visibleButtons, hidden: hiddenButtons }

            };

        };



        // DEBUG: Test user selection control (Web)

        window.debugUserSelectionWeb = () => {

            const switcher = document.getElementById('userSwitcher');

            console.log('👤 WEB USER SELECTION STATE:');

            console.log('├── Disabled:', switcher?.disabled);

            console.log('├── Opacity:', switcher?.style.opacity);

            console.log('├── Cursor:', switcher?.style.cursor);

            console.log('├── Checkout state:', currentDocumentState.isCheckedOut);

            console.log('└── Checked out by:', currentDocumentState.checkedOutBy);

             
            
            return {

                disabled: switcher?.disabled,

                checkoutState: currentDocumentState.isCheckedOut,

                checkedOutBy: currentDocumentState.checkedOutBy

            };

        };



        // DEBUG: Test web independent user system

        window.debugWebUserSystem = async () => {

            console.log('🧪 WEB USER SYSTEM TEST:');

            console.log('='.repeat(50));

             
            
            try {

                // Test current user endpoint

                const currentResp = await fetch('http://localhost:3001/api/user/web/current');

                const currentData = await currentResp.json();

                console.log('1. Web current user API:', currentData.user.name, `(${currentData.user.role})`);

                 
                
                // Test users list endpoint  

                const usersResp = await fetch('http://localhost:3001/api/user/web/users');

                const usersData = await usersResp.json();

                console.log('2. Web users available:', usersData.users.map(u => `${u.name} (${u.role})`));

                 
                
                // Test local state

                console.log('3. Local currentUser:', currentUser?.name, `(${currentUser?.role})`);

                console.log('4. Local allUsers:', allUsers.map(u => `${u.name} (${u.role})`));

                 
                
                // Test status includes web user

                const statusResp = await fetch('http://localhost:3001/api/status');

                const statusData = await statusResp.json();

                console.log('5. Status webUser:', statusData.checkoutState.webUser?.name);

                console.log('6. Status wordUser:', statusData.checkoutState.wordUser?.name);

                 
                
                return {

                    webUserAPI: currentData.user,

                    localUser: currentUser,

                    platformUsers: statusData.platformUsers

                };

            } catch (error) {

                console.error('❌ Web user system test failed:', error);

            }

        };



        // Add click animation to all buttons with interruption protection

        function addButtonClickAnimation() {

            let activeAnimations = new Map();

             
            
            document.addEventListener('click', function(e) {

                const button = e.target.closest('button') || e.target.closest('.btn') || e.target.closest('.button');

                if (!button) return;

                 
                
                // Clear any existing animation for this button

                if (activeAnimations.has(button)) {

                    clearTimeout(activeAnimations.get(button));

                    button.classList.remove('btn-clicked');

                }

                 
                
                // Start new animation

                button.classList.add('btn-clicked');

                 
                
                // Store timeout reference for this specific button

                const timeoutId = setTimeout(() => {

                    button.classList.remove('btn-clicked');

                    activeAnimations.delete(button);

                    // Re-enable pointer events

                    button.style.pointerEvents = '';

                }, 300); // Match the CSS animation duration

                 
                
                activeAnimations.set(button, timeoutId);

            });

             
            
            // Add protection against DOM changes interrupting animations

            const observer = new MutationObserver(function(mutations) {

                mutations.forEach(function(mutation) {

                    if (mutation.type === 'childList' || mutation.type === 'attributes') {

                        // Check if any animated buttons still exist and maintain their animation

                        activeAnimations.forEach((timeoutId, button) => {

                            if (document.contains(button) && button.classList.contains('btn-clicked')) {

                                // Ensure animation continues even if DOM changed

                                button.style.animation = 'buttonClick 0.3s ease-out';

                                button.style.zIndex = '9999';

                                button.style.position = 'relative';

                            }

                        });

                    }

                });

            });

             
            
            observer.observe(document.body, {

                childList: true,

                subtree: true,

                attributes: true,

                attributeFilter: ['class', 'style']

            });

        }



        // Initialize button animations when page loads

        window.addEventListener('load', function() {

            addButtonClickAnimation();

        });

         
        
        // Make test functions available globally

        window.testUserSystem = testUserSystem;

        window.debugUserState = debugUserState;

        window.debugWebViewerState = debugWebViewerState;

        window.debugWebProtectionLayers = debugWebProtectionLayers;

         
        
        // Immediate availability check

        console.log('🧪 Test functions loaded:', {

            testUserSystem: typeof window.testUserSystem,

            debugUserState: typeof window.debugUserState

        });

         
        
        // Button visibility helper functions

        function hideButtons(buttonIds) {

            buttonIds.forEach(id => {

                const button = document.getElementById(id);

                if (button) {

                    button.style.display = 'none';

                }

            });

        }

         
        
        function showButtons(buttonIds) {

            buttonIds.forEach(id => {

                const button = document.getElementById(id);

                if (button) {

                    button.style.display = 'block';

                }

            });

        }

         
        
        // Multi-layer document protection detection for web viewer

        function determineWebViewerAccess() {

            console.log('🔍 WEB: Determining document access levels...');

             
            
            const result = {

                canEdit: false,

                reason: '',

                layers: {

                    fileLevel: { readOnly: false, detected: false },

                    userLevel: { canEdit: false, role: '' },

                    collaborationLevel: { available: true, checkedOutBy: null }

                }

            };

             
            
            // Layer 1: File-level protection (not detectable in web viewer)

            console.log('📄 Layer 1: File-level protection (web viewer limitation)');

            result.layers.fileLevel.detected = false;

            result.layers.fileLevel.readOnly = false; // Cannot detect in web

            console.log('   ⚠️ File protection detection not available in web viewer');

             
            
            // Layer 2: User role-based restrictions

            console.log('👤 Layer 2: Checking user role permissions...');

            const userRole = getCurrentUserRole();

            const userCanEdit = canCurrentUserEdit();

            result.layers.userLevel.role = userRole;

            result.layers.userLevel.canEdit = userCanEdit;

             
            
            console.log(`   User role: ${userRole}, Can edit: ${userCanEdit}`);

             
            
            if (!userCanEdit) {

                result.canEdit = false;

                result.reason = 'user-viewer';

                console.log('   ❌ User is viewer - denying edit access');

                return result;

            }

             
            
            // Layer 3: Collaboration state (checkout system)

            console.log('🤝 Layer 3: Checking collaboration state...');

            const isCheckedOutByOther = currentDocumentState.isCheckedOut && currentDocumentState.checkedOutBy !== 'web';

            result.layers.collaborationLevel.available = !isCheckedOutByOther;

            result.layers.collaborationLevel.checkedOutBy = isCheckedOutByOther ? currentDocumentState.checkedOutBy : null;

             
            
            console.log(`   Checked out by other: ${isCheckedOutByOther}, User: ${currentDocumentState.checkedOutBy || 'none'}`);

             
            
            if (isCheckedOutByOther) {

                result.canEdit = false;

                result.reason = 'checked-out';

                console.log(`   ❌ Document checked out by ${currentDocumentState.checkedOutBy} - denying edit access`);

                return result;

            }

             
            
            // All accessible layers allow editing

            result.canEdit = true;

            result.reason = 'full-access';

            console.log('   ✅ All accessible protection layers allow editing');

             
            
            return result;

        }



        // Enhanced visual feedback system for web viewer

        function updateWebUIForAccessLevel(accessInfo) {

            console.log('🎨 WEB STEP 2: Updating UI based on access level:', accessInfo.reason);

             
            
            const viewerContainer = document.querySelector('.viewer-container');

             
            
            if (!accessInfo.canEdit) {

                // Apply read-only mode

                // State matrix now controls all button visibility - only hide non-matrix buttons

                hideButtons(['openBtn', 'viewOnlyBtn']);

                updateSuperdocMode('viewing');

                 
                
                // Apply read-only styling

                if (viewerContainer) {

                    viewerContainer.classList.remove('edit-mode');

                    viewerContainer.classList.add('read-only-mode');

                }

                 
                
                // Show context-specific status message

                let statusMessage = '';

                let statusType = 'info';

                 
                
                switch (accessInfo.reason) {

                    case 'user-viewer':

                        statusMessage = '👁️ Viewer access - read-only mode';

                        statusType = 'info';

                        break;

                    case 'checked-out':

                        statusMessage = `🔒 Document checked out by ${accessInfo.layers.collaborationLevel.checkedOutBy}`;

                        statusType = 'error';

                        break;

                    default:

                        statusMessage = '🔒 Read-only access';

                        statusType = 'info';

                }

                 
                
                showStatus(statusMessage, statusType);

                console.log(`🎨 WEB: Applied read-only mode: ${accessInfo.reason}`);
                
                 
                
            } else {

                // Apply edit mode styling

                if (viewerContainer) {

                    viewerContainer.classList.remove('read-only-mode');

                    viewerContainer.classList.add('edit-mode');

                }

                 
                
                showStatus('✅ Document ready for editing', 'success');

                console.log('🎨 WEB: Applied edit mode: full access granted');

             }

         }




         
        
        // Update SuperDoc editing mode based on checkout state

        function updateSuperdocMode(mode) {

            if (currentSuperdoc) {

                try {

                    // Try to update the mode if SuperDoc supports it

                    if (currentSuperdoc.setMode) {

                        currentSuperdoc.setMode(mode);

                        console.log(`SuperDoc mode updated to: ${mode}`);

                    } else if (currentSuperdoc.setReadOnly) {

                        // Alternative API if available

                        currentSuperdoc.setReadOnly(mode === 'viewing');

                        console.log(`SuperDoc read-only set to: ${mode === 'viewing'}`);

                    } else {

                        // If no direct method, we'll need to reinitialize

                        console.log(`SuperDoc mode change not supported by current API - mode should be: ${mode}`);

                         
                        
                        // Update visual styling for read-only mode

                        const superdocElement = document.getElementById('superdoc');

                         
                        
                        if (mode === 'viewing') {

                            superdocElement.style.opacity = '0.8';

                            superdocElement.style.pointerEvents = 'none';

                        } else {

                            superdocElement.style.opacity = '1';

                            superdocElement.style.pointerEvents = 'auto';

                        }

                    }

                } catch (error) {

                    console.error('Error updating SuperDoc mode:', error);

                }

            }



            // Enforce suggestor/vendor lock: when suggesting, block direct edits at the DOM level

            const editorRoot = document.getElementById('superdoc');

            if (editorRoot) {

                if (mode === 'suggesting') {

                    editorRoot.classList.add('suggesting-guard');

                    editorRoot.addEventListener('beforeinput', suggestingGuardHandler, { passive: false });

                } else {

                    editorRoot.classList.remove('suggesting-guard');

                    editorRoot.removeEventListener('beforeinput', suggestingGuardHandler, { passive: false });

                }

            }

        }



        function suggestingGuardHandler(event) {

            const blockedTypes = ['insertText', 'insertFromPaste', 'deleteByCut', 'deleteContentBackward', 'deleteContentForward'];

            if (blockedTypes.includes(event.inputType)) {

                event.preventDefault();

            }

        }

         
        
        // Fetch current document status

        async function fetchDocumentStatus() {

            try {

                const response = await fetch('http://localhost:3001/api/status');

                if (response.ok) {

                    const data = await response.json();

                    currentDocumentState.isCheckedOut = data.checkoutState.isCheckedOut;

                    currentDocumentState.checkedOutBy = data.checkoutState.checkedOutBy;

                    currentDocumentState.checkedOutUser = data.checkoutState.checkedOutUser || null;

                    currentDocumentState.checkedOutUserId = data.checkoutState.checkedOutUserId || null;

                    currentDocumentState.currentDocument = data.currentDocument;

                    // Update state matrix after status change

                    updateButtonVisibilityFromMatrix();


                }

            } catch (error) {

                console.error('Failed to fetch document status:', error);

            }

        }

         
        
        // Checkout document

        async function checkoutDocument() {

            try {

                const response = await fetch('http://localhost:3001/api/checkout', {

                    method: 'POST',

                    headers: { 'Content-Type': 'application/json' },

                    body: JSON.stringify({ source: 'web' })

                });

                 
                
                if (response.ok) {

                    showStatus('✅ Document checked out successfully', 'success');
                    
                     

                     // Disable user selection during checkout
                     await fetchDocumentStatus(); // Refresh UI
                     await updateUIFromStateMatrix('web', getCurrentUser, getCurrentUserRole, currentDocumentState);
                     
                    
                    // Try to load the current document

                    if (currentDocumentState.currentDocument && currentDocumentState.currentDocument.id) {

                        await loadSuperdoc(currentDocumentState.currentDocument.id, currentDocumentState.currentDocument.filename);

                    }

                } else {

                    const error = await response.json();

                    showStatus(`❌ ${error.error}`, 'error');

                }

            } catch (error) {

                console.error('Checkout error:', error);

                showStatus('❌ Checkout failed: ' + error.message, 'error');

            }

        }

         
        
        // Extract document content from SuperDoc

        async function extractSuperdocContent() {

            try {

                if (!currentSuperdoc) {

                    console.log('No SuperDoc instance available');

                    return null;

                }

                 
                
                // Try SuperDoc's export method if available

                if (currentSuperdoc.exportEditorsToDOCX && typeof currentSuperdoc.exportEditorsToDOCX === 'function') {

                    console.log('Using SuperDoc exportEditorsToDOCX method...');

                    const exportResult = await currentSuperdoc.exportEditorsToDOCX();

                     
                    
                    if (exportResult && exportResult.length > 0) {

                        const blob = exportResult[0];

                        console.log('SuperDoc export successful, blob size:', blob.size);

                         
                        
                        // Convert blob to base64

                        return new Promise((resolve, reject) => {

                            const reader = new FileReader();

                            reader.onload = function() {

                                const base64 = reader.result.split(',')[1]; // Remove data URL prefix

                                resolve({ format: 'base64', data: base64 });

                            };

                            reader.onerror = reject;

                            reader.readAsDataURL(blob);

                        });

                    }

                }

                 
                
                // Fallback: return null if no export method available

                console.log('SuperDoc export not available, returning null');

                return null;
                
                 
                
            } catch (error) {

                console.error('SuperDoc content extraction failed:', error);

                return null;

            }

        }

         
        
        // Save progress (keep checkout)

        async function saveProgress() {

            try {

                showStatus('💾 Saving progress...', 'info');

                 
                
                // Extract actual document content from SuperDoc

                const extractedContent = await extractSuperdocContent();

                 
                
                const response = await fetch('http://localhost:3001/api/save-progress', {

                    method: 'POST',

                    headers: { 'Content-Type': 'application/json' },

                    body: JSON.stringify({ 

                        source: 'web',

                        docx: extractedContent?.data,

                        filename: currentDocumentState.currentDocument?.filename || 'web-progress-save.docx'

                    })

                });

                 
                
                if (response.ok) {

                    showStatus('✅ Progress saved successfully', 'success');

                } else {

                    const error = await response.json();

                    showStatus(`❌ ${error.error}`, 'error');

                }

            } catch (error) {

                console.error('Save progress error:', error);

                showStatus('❌ Save failed: ' + error.message, 'error');

            }

        }

         
        
        // Check-in document (save and unlock)

        async function checkinDocument() {

            try {

                showStatus('✅ Checking in document...', 'info');

                 
                
                // Extract actual document content from SuperDoc

                const extractedContent = await extractSuperdocContent();

                 
                
                const response = await fetch('http://localhost:3001/api/checkin', {

                    method: 'POST',

                    headers: { 'Content-Type': 'application/json' },

                    body: JSON.stringify({ 

                        source: 'web',

                        userId: getCurrentUser()?.id,

                        docx: extractedContent?.data
                        // filename intentionally omitted; server writes to current.docx

                    })

                });

                 
                
                if (response.ok) {

                    showStatus('✅ Document checked in successfully', 'success');
                    
                     

                     // Re-enable user selection after successful checkin
                     await fetchDocumentStatus(); // Refresh UI
                     await updateUIFromStateMatrix('web', getCurrentUser, getCurrentUserRole, currentDocumentState);
                } else {

                    const error = await response.json();

                    showStatus(`❌ ${error.error}`, 'error');

                }

            } catch (error) {

                console.error('Checkin error:', error);

                showStatus('❌ Check-in failed: ' + error.message, 'error');

            }

        }

         
        
        // Cancel checkout (unlock without saving)

        async function cancelCheckout() {

            try {

                const response = await fetch('http://localhost:3001/api/cancel-checkout', {

                    method: 'POST',

                    headers: { 'Content-Type': 'application/json' },

                    body: JSON.stringify({ source: 'web', userId: getCurrentUser()?.id })

                });

                 
                
                if (response.ok) {

                    showStatus('✅ Checkout cancelled', 'success');
                    
                     

                     // Re-enable user selection after cancelling checkout
                     await fetchDocumentStatus(); // Refresh UI
                     await updateUIFromStateMatrix('web', getCurrentUser, getCurrentUserRole, currentDocumentState);
                } else {

                    const error = await response.json();

                    showStatus(`❌ ${error.error}`, 'error');

                }

            } catch (error) {

                console.error('Cancel checkout error:', error);

                showStatus('❌ Cancel failed: ' + error.message, 'error');

            }

        }

         
        
        // View read-only (load latest without checkout)

        async function viewReadOnly() {

            try {

                showStatus('👀 Loading latest version...', 'info');

                 
                
                const response = await fetch('http://localhost:3001/api/status');

                if (response.ok) {

                    const data = await response.json();

                    if (data.currentDocument && data.currentDocument.id) {

                        // Use the correct loadSuperdoc function that expects documentData object

                        await loadSuperdoc(data.currentDocument);

                        showStatus('👀 Latest version loaded (read-only)', 'info');

                    } else {

                        showStatus('❌ No document available', 'error');

                    }

                } else {

                    throw new Error('Failed to get document status');

                }

            } catch (error) {

                console.error('View read-only error:', error);

                showStatus('❌ Failed to load: ' + error.message, 'error');

            }

        }



        // OLD loadSuperdoc function removed - using the unified one below



        // Save functions will go here



        function showStatus(message, type, elementId = 'documentStatus') {

            // Status banners removed - notifications now go to modal only

            console.log(`📋 Status: ${message} (${type})`);

             
            
            // Add to notification history (except for SSE connection messages)

            if (elementId !== 'sseStatus') {

                addNotification(message, type);

            }

        }



        function openNewFile() {

            document.getElementById('fileInput').click();

        }

         
        
        function openNotificationModal() {

            console.log('🔔 Opening notification modal...');

            const modal = document.getElementById('notificationModal');

            modal.style.display = 'flex';

             
            
            // Render current notifications

            renderNotifications();

        }

         
        
        function closeNotificationModal() {

            console.log('🔔 Closing notification modal...');

            const modal = document.getElementById('notificationModal');

            modal.style.display = 'none';

             
            
            // Mark all notifications as read when modal is closed

            markAllNotificationsAsRead();

         }        

         // ===== MODAL HELPERS =====

         // Ensure only one modal is visible at a time
         window.closeAllModals = function closeAllModals(){
             try { document.getElementById('usersModal')?.style.setProperty('display','none','important'); } catch(_){ }
             try { document.getElementById('vendorModal')?.style.setProperty('display','none','important'); } catch(_){ }
             try { document.getElementById('vendorConfirmationModal')?.style.setProperty('display','none','important'); } catch(_){ }
             try { document.getElementById('notificationModal')?.style.setProperty('display','none','important'); } catch(_){ }
             try { document.getElementById('templatesModalWeb')?.style.setProperty('display','none','important'); } catch(_){ }
             try { document.getElementById('approvalsModalWeb')?.style.setProperty('display','none','important'); } catch(_){ }
             // Ensure hidden modals do not intercept clicks
             try { document.getElementById('usersModal')?.style.setProperty('pointer-events','none','important'); } catch(_){ }
             try { document.getElementById('vendorModal')?.style.setProperty('pointer-events','none','important'); } catch(_){ }
             try { document.getElementById('vendorConfirmationModal')?.style.setProperty('pointer-events','none','important'); } catch(_){ }
             try { document.getElementById('notificationModal')?.style.setProperty('pointer-events','none','important'); } catch(_){ }
             try { document.getElementById('templatesModalWeb')?.style.setProperty('pointer-events','none','important'); } catch(_){ }
             try { document.getElementById('backToOpenGovModal')?.style.setProperty('pointer-events','none','important'); } catch(_){ }
             try { document.getElementById('approvalsModalWeb')?.style.setProperty('pointer-events','none','important'); } catch(_){ }
         };

         // Generic modal opener used by all features (vendor, approvals, templates)
         window.openModalById = function openModalById(modalId){
             var modal = document.getElementById(modalId);
             if(!modal){ console.warn('Modal not found:', modalId); return; }
             try { window.closeAllModals && window.closeAllModals(); } catch(_){}
             try { document.body.appendChild(modal); } catch(_){}
             modal.style.setProperty('display','flex','important');
             modal.style.setProperty('position','fixed','important');
             modal.style.setProperty('inset','0','important');
             modal.style.setProperty('z-index','2147483647','important');
             modal.style.setProperty('pointer-events','auto','important');
         };

        // ===== VENDOR MODAL FUNCTIONS =====

         
        
        function openVendorModal() {

            console.log('Opening vendor modal...');

              window.openModalById && window.openModalById('vendorModal');

        }



        // Wire approvals summary for web

        (function setupApprovalsSummaryWeb(){

            function open() {

                 console.log('🔔 WEB: Opening approvals modal...');
                  window.openModalById && window.openModalById('usersModal');
                  try { refreshUsersModal(); } catch(e) { console.error('refreshUsersModal failed', e); }
             }

            function updatePill(approved, total) {

                 console.log(`📊 WEB: updatePill called with approved=${approved}, total=${total}`);
                const pill = document.getElementById('approvalsPillWeb');

                 console.log(`📊 WEB: Found pill element:`, !!pill);
                 if (pill) {
                     const newText = `${approved}/${total} approved`;
                     console.log(`📊 WEB: Setting pill text to: "${newText}"`);
                     pill.textContent = newText;
                 } else {
                     console.warn(`📊 WEB: approvalsPillWeb element not found!`);
                 }
             }
             
             // Make open function globally available for the state matrix client
             window.openUsersModalWeb = open;
             // Pill function moved earlier to be available when SSE connects
             
            setTimeout(() => {

                try {

                    const btn = document.getElementById('btnApprovalsDetailsWeb');

                     console.log('🔔 WEB: Wiring approvals button...', !!btn);
                     if (btn) {
                         btn.onclick = open;
                         console.log('🔔 WEB: Button onclick handler assigned');
                     } else {
                         console.error('❌ WEB: btnApprovalsDetailsWeb not found!');
                     }
                 } catch(e) {
                     console.error('❌ WEB: Error wiring button:', e);
                 }
            }, 0);

        })();

         
        
        function closeVendorModal() {

            console.log('Closing vendor modal...');

            const modal = document.getElementById('vendorModal');

            modal.style.display = 'none';

        }

         
        
        function openVendorConfirmationModal() {

            console.log('✅ Opening vendor confirmation modal...');

            const modal = document.getElementById('vendorConfirmationModal');

            modal.style.display = 'flex';

        }

         
        
        function closeVendorConfirmationModal() {

            console.log('✅ Closing vendor confirmation modal...');

            const modal = document.getElementById('vendorConfirmationModal');

            modal.style.display = 'none';

        }



        // Override vendor checkout

        async function overrideCheckout() {

            console.log("🔓 Overriding checkout...");

            try {

                const response = await fetch("http://localhost:3001/api/override", {

                    method: "POST",

                    headers: { "Content-Type": "application/json" },

                    body: JSON.stringify({ source: "web" })

                });

                const result = await response.json();

                if (result.success) {

                    addNotification("Document reclaimed", "success");

                    await fetchDocumentStatus();

                    // Update state matrix after status change

                    updateButtonVisibilityFromMatrix();

                } else {

                    addNotification("Failed to override checkout", "error");

                }

            } catch (error) {

                console.error("Error Overriding checkout:", error);

                addNotification("Error Overriding checkout", "error");

            }

        }

         
        
        async function sendToVendor(event) {

            event.preventDefault();

             
            
            const vendor = document.getElementById('vendorCompany').value;

            const name = document.getElementById('vendorName').value;

            const email = document.getElementById('vendorEmail').value;

            const notes = document.getElementById('vendorNotes').value;

             
            
            console.log(`Sending document to vendor: ${vendor} (${name} - ${email})`);

            if (notes) {

                console.log(`📝 Notes: ${notes}`);

            }

             
            
            try {

                const response = await fetch('http://localhost:3001/api/vendor/send', {

                    method: 'POST',

                    headers: { 'Content-Type': 'application/json' },

                    body: JSON.stringify({

                        vendor: vendor,

                        name: name,

                        email: email,

                        notes: notes,

                        source: 'web'

                    })

                });

                 
                
                const result = await response.json();

                 
                
                if (result.success) {

                    addNotification('Vendor has been invited to redline', 'success');

                    closeVendorModal();

                    // Show confirmation modal

                    openVendorConfirmationModal();

                    // No need to update button states - document stays unlocked, vendor is just invited

                } else {

                    addNotification(`Failed to send to vendor: ${result.error}`, 'error');

                }

            } catch (error) {

                console.error('Error sending to vendor:', error);

                addNotification('Error sending document to vendor', 'error');

            }

        }

         
        
        // ===== NOTIFICATION SYSTEM =====

         
        
        function addNotification(message, type = 'info') {

            const notification = {

                id: ++notificationIdCounter,

                message: message,

                type: type, // 'success', 'error', 'info'

                timestamp: new Date(),

                isRead: false,

                platform: 'web'

            };

             
            
            notificationHistory.unshift(notification); // Add to beginning

            hasUnreadNotifications = true;

            updateNotificationDot();

            renderNotifications(); // Update both modal and window

            // Increment bell badge if modal is closed
            try {
                const modal = document.getElementById('notificationModal');
                const isOpen = modal && getComputedStyle(modal).display !== 'none';
                const badge = document.getElementById('notificationBellBadge');
                if (badge && !isOpen) {
                    const current = parseInt(badge.textContent || '0', 10) || 0;
                    const next = current + 1;
                    badge.textContent = String(next);
                    badge.style.display = next > 0 ? 'inline-block' : 'none';
                }
            } catch(_) {}

             
            
            console.log('📝 Added notification:', notification);

             
            
            // Limit history to last 50 notifications

            if (notificationHistory.length > 50) {

                notificationHistory = notificationHistory.slice(0, 50);

            }

        }

         
        
        function renderNotifications() {

            const modalBody = document.getElementById('notificationModalBody');

            const windowBody = document.getElementById('notificationWindowBody_grid') || document.getElementById('notificationWindowBody');

             
            
            if (notificationHistory.length === 0) {

                const noNotificationsHtml = '<div class="no-notifications">No notifications yet</div>';

                if (modalBody) modalBody.innerHTML = noNotificationsHtml;

                if (windowBody) windowBody.innerHTML = noNotificationsHtml;

                return;

            }

             
            
            const notificationsHtml = notificationHistory.map(notification => {

                const timeAgo = getTimeAgo(notification.timestamp);

                return `

                    <div class="notification-item ${notification.type}">

                        <p class="notification-message">${notification.message}</p>

                        <p class="notification-timestamp">${timeAgo}</p>

                    </div>

                `;

            }).join('');

             
            
            // Update both modal and transparent window

            if (modalBody) modalBody.innerHTML = notificationsHtml;

            if (windowBody) windowBody.innerHTML = notificationsHtml;

        }

         
        
        function getTimeAgo(timestamp) {

            const now = new Date();

            const diff = now - timestamp;

            const seconds = Math.floor(diff / 1000);

            const minutes = Math.floor(seconds / 60);

            const hours = Math.floor(minutes / 60);

             
            
            if (seconds < 60) return `${seconds} seconds ago`;

            if (minutes < 60) return `${minutes} minutes ago`;

            if (hours < 24) return `${hours} hours ago`;

            return timestamp.toLocaleDateString();

        }

         
        
        function updateNotificationDot() {

            const dot = document.getElementById('notificationDot');

            if (dot) {

            dot.style.display = hasUnreadNotifications ? 'block' : 'none';

            }

            // Note: notificationDot was removed when we moved to the notification window

        }

         
        
        function markAllNotificationsAsRead() {

            notificationHistory.forEach(notification => {

                notification.isRead = true;

            });

            hasUnreadNotifications = false;

            updateNotificationDot();

            // Also clear the bell badge
            try {
                const badge = document.getElementById('notificationBellBadge');
                if (badge) { badge.textContent = '0'; badge.style.display = 'none'; }
            } catch(_) {}

        }

         
        
        // Test function for generating sample notifications

        function testNotifications() {

            addNotification('✅ Document checkout successful', 'success');

            addNotification('📋 Document saved successfully', 'success');

            addNotification('⚠️ Connection temporarily lost', 'error');

            addNotification('📡 Real-time sync enabled', 'info');

            console.log('🧪 Test notifications added');

        }

         
        
        // Make test function globally available

        window.testNotifications = testNotifications;
        
         

         // ===== CHECKOUT BANNER SYSTEM =====

         

         
         

         
        
        // Make test function globally available

         
        
        // Debug function to check current state

        function debugCurrentState() {

            console.log('🔍 CURRENT STATE DEBUG:');

            console.log('  isCheckedOut:', currentDocumentState.isCheckedOut);

            console.log('  checkedOutBy:', currentDocumentState.checkedOutBy);

            console.log('  User role:', getCurrentUserRole());

            console.log('  Scenario:', null /* TODO: replace with state matrix */);

             
            
            // Check button visibility

            ['checkoutBtn', 'overrideVendorBtn', 'sendVendorBtn'].forEach(id => {

                const btn = document.getElementById(id);

                console.log(`  ${id}: ${btn ? (btn.style.display || 'visible') : 'missing'}`);

            });

        }

        window.debugCurrentState = debugCurrentState;

         
        
        // Debug function for button visibility issues

        function debugWebViewerButtons() {

            console.log('🔍 WEB VIEWER BUTTON DEBUG:');

            console.log('├── Current document state:', currentDocumentState);

            console.log('├── Detected scenario:', null /* TODO: replace with state matrix */);

            console.log('├── Button elements exist:');

             
            
            ['checkoutBtn', 'sendVendorBtn', 'overrideVendorBtn', 'saveProgressBtn', 'checkinBtn', 'cancelBtn', 'viewOnlyBtn'].forEach(buttonId => {

                const button = document.getElementById(buttonId);

                console.log(`│   ├── ${buttonId}: ${!!button ? 'EXISTS' : 'MISSING'} - Display: ${button?.style.display || 'undefined'}`);

                if (button) {

                    console.log(`│   │   └── Text: "${button.textContent.trim()}"`);

                }

            });

             
            
            console.log('└── Applying state matrix button visibility now...');

            updateButtonVisibilityFromMatrix();

        }

         
        
        // Make debug function globally available

        window.debugWebViewerButtons = debugWebViewerButtons;

         
        
        async function handleFileSelect(event) {

            const file = event.target.files[0];

            if (!file) return;

             
            
            if (!file.name.endsWith('.docx') && !file.name.endsWith('.doc')) {

                showStatus('Please select a Word document (.docx or .doc)', 'error');

                return;

            }

             
            
            showStatus(`Loading ${file.name}...`, 'info');

             
            
            try {

                // Read file as ArrayBuffer

                const arrayBuffer = await file.arrayBuffer();

                 
                
                // Convert to base64

                const uint8Array = new Uint8Array(arrayBuffer);

                let binaryString = '';

                const chunkSize = 8192; // Process in chunks

                 
                
                for (let i = 0; i < uint8Array.length; i += chunkSize) {

                    const chunk = uint8Array.slice(i, i + chunkSize);

                    binaryString += String.fromCharCode.apply(null, chunk);

                }

                 
                
                const base64 = btoa(binaryString);

                 
                
                // Replace default document via API server
                const response = await fetch('http://localhost:3001/api/replace-default', {

                    method: 'POST',

                    headers: {

                        'Content-Type': 'application/json'

                    },

                    body: JSON.stringify({ base64Docx: base64, originalFilename: file.name })

                });

                 
                
                if (!response.ok) {

                    throw new Error('Failed to upload file');

                }

                 
                
                const result = await response.json();

                 
                
                // Load the uploaded document in SuperDoc

                const docId = (result && result.currentDocument && result.currentDocument.id) || (result && result.documentId) || 'doc-current';
                await loadSuperdoc(docId, file.name);
                
                 
                
            } catch (error) {

                console.error('File open error:', error);

                showStatus('Failed to open file: ' + error.message, 'error');

            }

             
            
            // Clear the file input for next time

            event.target.value = '';

        }



        // ===== MILESTONE 1: STATE DETECTION LOGIC =====

         
        
        // Old scenario detection removed; state matrix now drives UI.

         
        
        // Debug helper: Show current collaboration state

        function debugCurrentState() {

            const hasServerDoc = !!(currentDocumentState.currentDocument && currentDocumentState.currentDocument.id);

            const hasLocalDoc = !!(currentSuperdoc && currentDocumentId);

             
            
            console.log('🔍 WEB VIEWER STATE ANALYSIS:');

            console.log('├── Server has document:', hasServerDoc);

            console.log('├── Web has document:', hasLocalDoc);

            console.log('├── Is checked out:', currentDocumentState.isCheckedOut);

            console.log('├── Checked out by:', currentDocumentState.checkedOutBy);

            console.log('├── Current document:', currentDocumentState.currentDocument?.filename || 'None');

            console.log('├── SuperDoc instance:', !!currentSuperdoc);

            console.log('├── Current document ID:', currentDocumentId || 'None');

            console.log('└── Detected scenario:', null /* TODO: replace with state matrix */);

             
            
            return {

                hasServerDoc,

                hasLocalDoc,

                isCheckedOut: currentDocumentState.isCheckedOut,

                checkedOutBy: currentDocumentState.checkedOutBy,

                scenario: null /* TODO: replace with state matrix */,

                superdocActive: !!currentSuperdoc,

                documentId: currentDocumentId

            };

        }

         
        
        // Debug helper: Get currently visible buttons

        function getVisibleButtons() {

            return Array.from(document.querySelectorAll('button'))

                .filter(btn => !btn.style.display || btn.style.display !== 'none')

                .map(btn => ({

                    id: btn.id,

                    text: btn.textContent.trim(),

                    visible: true

                }));

        }

         


        

        
        // ===== STATE MATRIX IMPLEMENTATION =====

         
        
        /**

         * Core state matrix lookup - directly implements USER_STATE_MATRIX.md

         * @param {string} userRole - viewer, editor, suggester, vendor

         * @param {string} platform - web, word  

         * @param {object} documentState - { isCheckedOut, checkedOutBy, checkedOutUser }

         * @returns {object} { buttons: {...}, banner: { text, show } }

         */






        
        /**

         * Main state matrix implementation - replaces old scenario logic

         */

        function updateButtonVisibilityFromMatrix() {

            // Use the shared state matrix client instead of local logic

            updateUIFromStateMatrix('web', getCurrentUser, getCurrentUserRole, currentDocumentState);

             
             // CRITICAL: Refresh dropdown after state matrix update
             if (window.__lastStateMatrix && typeof window.refreshActionsDropdownFromMatrix === 'function') {
                 window.refreshActionsDropdownFromMatrix('webDocActionsSelect', window.__lastStateMatrix);
                 console.log('🔄 WEB: Dropdown refreshed after state matrix update');
             }
             

             
            renderNotifications();

         }

         
         // DYNAMIC DROPDOWN: Use same approach as Word add-in  
         async function refreshWebDropdownFromMatrix() {
             console.log('🔄 WEB: Dropdown clicked - refreshing from live state matrix...');
             try {
                 // Step 1: Get fresh state matrix (same as Word add-in)
                 await updateUIFromStateMatrix('web', getCurrentUser, getCurrentUserRole, currentDocumentState);
                 
                 // Step 2: Use shared function to rebuild dropdown (same as Word add-in)
                 if (window.__lastStateMatrix && typeof window.refreshActionsDropdownFromMatrix === 'function') {
                     window.refreshActionsDropdownFromMatrix('webDocActionsSelect', window.__lastStateMatrix);
                     console.log('🔄 WEB: Dropdown rebuilt with fresh state matrix data');
                 }
             } catch (e) {
                 console.warn('⚠️ WEB: Failed to refresh dropdown from matrix:', e);
             }
         }
         
        
        // ===== END STATE MATRIX IMPLEMENTATION =====

         
         // Make action functions globally available for dropdown to call
         window.checkoutDocument = checkoutDocument;
         window.checkinDocument = checkinDocument;
         window.cancelCheckout = cancelCheckout;
         window.viewReadOnly = viewReadOnly;
         window.openVendorModal = openVendorModal;
         window.onWebDocActionChange = function(val){
             if (val === 'compile') {
                 try { document.getElementById('compileModal').style.display = 'block'; buildCompileModalWeb(); } catch(_){}
                 const sel = document.getElementById('webDocActionsSelect'); if (sel) sel.value = '';
             } else if (val === 'finalize' || val === 'unfinalize') {
                  try {
                      const cfg = (window.__lastStateMatrix && window.__lastStateMatrix.finalize) || {};
                      const isUn = (val === 'unfinalize');
                      const meta = isUn ? (cfg.unfinalize || {}) : (cfg.confirm || {});
                      const title = meta.title || (isUn ? 'Move back to Draft?' : 'Please confirm you\'d like to finalize.');
                      const body = meta.body || (isUn ? 'Editors can edit again; approvals may need to be re-requested.' : 'After finalizing, the document is locked and the first approver is notified.');
                      const label = meta.confirmLabel || (isUn ? 'Move to Draft' : 'Finalize');
                      const tone = meta.toneColor || '#fff3cd';
                      const toneText = meta.toneTextColor || '#111827';

                      const host = document.body;
                      const overlay = document.createElement('div');
                      overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.35);z-index:2147483646;display:flex;align-items:center;justify-content:center;';
                      const modal = document.createElement('div');
                      modal.id = 'ogFinalize';
                      modal.style.cssText = 'background:#fff;border-radius:8px;min-width:360px;max-width:520px;padding:14px 16px;box-shadow:0 8px 30px rgba(0,0,0,0.2);';
                      const style = document.createElement('style');
                      style.textContent = '#ogFinalize .btn{background:#1f2937 !important;color:#fff !important;border:none !important;border-radius:6px !important;padding:8px 12px !important;} #ogFinalize .btn-cancel{background:#e5e7eb !important;color:#000 !important;border:1px solid #d1d5db !important;border-radius:6px !important;padding:8px 12px !important;}';
                      const hdr = document.createElement('div'); hdr.textContent = title; hdr.style.cssText='font-weight:600;font-size:16px;margin-bottom:8px;';
                      const msg = document.createElement('div'); msg.textContent = body; msg.style.cssText=`background:${tone};color:${toneText};border-radius:6px;padding:8px 10px;margin-bottom:10px;`;
                      const actions = document.createElement('div'); actions.style.cssText='display:flex;gap:8px;justify-content:flex-end;';
                      const btnConfirm = document.createElement('button'); btnConfirm.textContent = label; btnConfirm.className='btn';
                      const btnCancel = document.createElement('button'); btnCancel.textContent = 'Cancel'; btnCancel.className='btn btn-cancel';
                      actions.appendChild(btnCancel); actions.appendChild(btnConfirm);
                      modal.appendChild(style); modal.appendChild(hdr); modal.appendChild(msg); modal.appendChild(actions); overlay.appendChild(modal); host.appendChild(overlay);

                      const resetSel = () => { const sel = document.getElementById('webDocActionsSelect'); if (sel) sel.value = ''; };
                      btnCancel.onclick = () => { try { overlay.remove(); } catch(_) {}; resetSel(); };
                      btnConfirm.onclick = async () => {
                          try {
                              btnConfirm.disabled = true; btnCancel.disabled = true;
                              const actorId = (window.currentUser && window.currentUser.id) || 'user1';
                              const endpoint = isUn ? '/api/unfinalize' : '/api/finalize';
                              const r = await fetch('http://localhost:3001' + endpoint, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ actorId }) });
                              if (!r.ok) throw new Error('finalize_toggle_failed');
                          } catch (e) {
                              try { window.addNotification && window.addNotification(isUn ? 'Unfinalize failed' : 'Finalize failed', 'error'); } catch(_) {}
                          } finally {
                              try { overlay.remove(); } catch(_) {}
                              resetSel();
                          }
                      };
                  } catch(_) {}
             }
         };
         window.closeCompileModal = function(){ try { document.getElementById('compileModal').style.display = 'none'; } catch(_){} };

         // ===== Web COMPILE modal: client + builder (mirrors add-in) =====
         // Fallback CompileClient for web if shared client not loaded
         (function ensureWebCompileClient(){
             if (window.CompileClient) return;
             try {
                 const BASE = 'http://localhost:3001';
                 const join = (p) => BASE + p;
                 const normalize = (err) => ({ code: (err && err.error) || 'unknown_error', message: (err && err.message) || '' });
                 async function ok(resp){ const ct = resp.headers.get('content-type') || ''; const isJson = ct.includes('application/json'); if (!resp.ok){ let b={}; try{ b=await resp.json(); }catch(_){} throw normalize(b); } return isJson ? resp.json() : resp; }
                 window.CompileClient = {
                     async getLimits(){ return (await ok(await fetch(join('/api/exhibits/limits')))).limits; },
                     async listExhibits(){ const d = await ok(await fetch(join('/api/exhibits/list'))); return { defaults: d.defaults || [], uploads: d.uploads || [] }; },
                     async uploadExhibit(file, userId){ const b64 = await new Promise((res, rej) => { const fr = new FileReader(); fr.onload = () => { const s = fr.result || ''; const c = s.indexOf(','); res(c >= 0 ? s.slice(c+1) : s); }; fr.onerror = rej; fr.readAsDataURL(file); }); const payload = { base64Pdf: b64, originalFilename: file && file.name, userId: userId || 'anonymous' }; const d = await ok(await fetch(join('/api/upload-exhibit'), { method:'POST', headers:{ 'Content-Type':'application/json' }, body: JSON.stringify(payload) })); return d.exhibit; },
                     async deleteExhibit(id){ await ok(await fetch(join('/api/exhibits/delete'), { method:'POST', headers:{ 'Content-Type':'application/json' }, body: JSON.stringify({ id }) })); return true; },
                     async compilePdf(params){ const payload = {}; if (params.primary === 'current' || (params.primary && params.primary.type === 'current')) { payload.primary = { type:'current', include: params.primary?.include !== false }; } else if (params.base64Pdf) { payload.base64Pdf = params.base64Pdf; } else { payload.primary = { type:'current', include:true }; } if (Array.isArray(params.exhibitsById)) payload.exhibitsById = params.exhibitsById; const r = await fetch(join('/api/compile'), { method:'POST', headers:{ 'Content-Type':'application/json' }, body: JSON.stringify(payload) }); if (!r.ok) { let b={}; try{ b = await r.json(); } catch(_){} throw normalize(b); } return await r.blob(); }
                 };
             } catch(_) {}
         })();

         function buildCompileModalWeb(){
             const host = document.getElementById('compileBodyWeb'); if (!host) return; host.innerHTML = '';
             const styleEl = document.createElement('style'); styleEl.textContent = '#compileModal .btn{background:#1f2937 !important;color:#fff !important;border:none !important;border-radius:6px !important;padding:8px 12px !important;} #compileModal .btn-cancel{background:#e9ecef !important;color:#000 !important;} #compileModal .btn-danger{background:#dc2626 !important;color:#fff !important;}'; host.appendChild(styleEl);
             const status = document.createElement('div'); status.id='compileStatusWeb'; status.style.display='none'; status.style.marginBottom='8px'; status.textContent='⏳ Compiling…'; host.appendChild(status);
             const section = document.createElement('div'); section.style.border='1px solid #e5e7eb'; section.style.borderRadius='6px'; section.style.padding='10px'; section.style.marginBottom='10px'; host.appendChild(section);
             const hdr = document.createElement('div'); hdr.style.display='flex'; hdr.style.alignItems='center'; hdr.style.justifyContent='space-between'; hdr.style.marginBottom='8px'; hdr.innerHTML = '<div style="font-weight:600">Exhibits</div>'; section.appendChild(hdr);
             const list = document.createElement('div'); list.id='exhibitsListWeb'; list.style.display='flex'; list.style.flexDirection='column'; list.style.gap='6px'; section.appendChild(list);
             const upInput = document.createElement('input'); upInput.type='file'; upInput.accept='application/pdf,.pdf'; upInput.style.display='none'; upInput.id='uploadExhibitInputWeb'; section.appendChild(upInput);
             const hint = document.createElement('div'); hint.style.color='#64748b'; hint.style.fontSize='12px'; hint.style.marginTop='6px'; hint.textContent='Testing 1, 2… but no more in the prototype (max 2 exhibits).'; section.appendChild(hint);
             const footer = document.createElement('div'); footer.style.display='flex'; footer.style.alignItems='center'; footer.style.justifyContent='space-between'; footer.style.gap='10px'; footer.innerHTML = (
                 '<div style="display:flex;align-items:center;gap:10px;">'
               + '  <button id="uploadBtnWeb" class="btn">Upload PDF</button>'
               + '</div>'
               + '<div style="display:flex;align-items:center;gap:8px;">'
               + '  <button id="cancelCompileWeb" class="btn btn-cancel" style="color:#000 !important;">Cancel</button>'
               + '  <button id="goCompileWeb" class="btn">Compile</button>'
               + '</div>'
             ); host.appendChild(footer);

             const uploadBtn = document.getElementById('uploadBtnWeb');
             const cancelBtn = document.getElementById('cancelCompileWeb');
             const goBtn = document.getElementById('goCompileWeb');
             let dl = document.getElementById('compileDownload');
             let lastUrl = null; const limits = { maxFiles: 2 }; const items = [];

             function addRow(meta, kind){
                 const base = String(meta.id || meta.filename || Math.random().toString(36).slice(2,8)); const safe = base.replace(/[^a-z0-9_-]/gi, '_'); const id = `w_${safe}`;
                 const row = document.createElement('div'); row.style.display='flex'; row.style.alignItems='center'; row.style.gap='8px';
                 const inp = document.createElement('input'); inp.type='checkbox'; inp.id=id;
                 const lab = document.createElement('label'); lab.setAttribute('for', id); lab.textContent = meta.originalFilename || meta.filename || meta.title || meta.name; lab.style.flex='1';
                 row.appendChild(inp); row.appendChild(lab);
                 if (kind === 'upload') { const del = document.createElement('button'); del.className='btn btn-danger'; del.textContent='Delete'; del.onclick = async () => { try { await CompileClient.deleteExhibit(meta.id); const idx = items.findIndex(x => x.meta.id === meta.id); if (idx >= 0) items.splice(idx,1); row.remove(); } catch(e){ console.warn(e); } }; row.appendChild(del); }
                 list.appendChild(row);
                 items.push({ meta, kind, inp });
             }

             async function refresh(){
                 list.innerHTML = ''; items.length = 0;
                 const data = await CompileClient.listExhibits();
                 const defs = (data.defaults || []); if (defs.length) addRow(defs[0], 'default');
                 const uid = (window.currentWebUser && window.currentWebUser.id) || 'user1';
                 (data.uploads || []).filter(u => (u.userId || 'anonymous') === uid).forEach(u => addRow(u, 'upload'));
             }

             uploadBtn.onclick = () => upInput.click();
             // No delete for default exhibits in prototype
             upInput.onchange = async (e) => { const f = e.target.files && e.target.files[0]; if (!f) return; const currentUploads = items.filter(x => x.kind === 'upload').length; if (currentUploads >= limits.maxFiles) { alert('Testing 1, 2… but no more in the prototype'); return; } const uid = (window.currentWebUser && window.currentWebUser.id) || 'user1'; try { await CompileClient.uploadExhibit(f, uid); await refresh(); } catch(err){ console.warn(err); } finally { upInput.value=''; } };
             cancelBtn.onclick = () => closeCompileModal();
             let busy = false;
             goBtn.onclick = async () => { if (busy) return; busy = true; const prev = goBtn.textContent; try { goBtn.disabled=true; cancelBtn.disabled=true; uploadBtn.disabled=true; status.style.display='block'; goBtn.textContent='Compiling…'; const exhibitsById = items.filter(x => x.inp.checked).map((x,i) => ({ id: x.meta.id || (x.meta.filename && x.meta.filename.replace(/\.pdf$/i,'')), include: true, order: i+1 })); const blob = await CompileClient.compilePdf({ primary:{ type:'current', include:true }, exhibitsById }); if (lastUrl) { try { URL.revokeObjectURL(lastUrl); } catch(_){} } const url = URL.createObjectURL(blob); lastUrl = url; if (!dl) { dl = document.createElement('a'); dl.id = 'compileDownload'; dl.style.display = 'none'; dl.download = 'compiled.pdf'; document.body.appendChild(dl); } dl.href = url; dl.style.display = 'inline-block'; try { dl.click(); } catch(_){} } catch(err){ console.warn(err); alert((err && err.message) || 'Compile failed'); } finally { status.style.display='none'; goBtn.disabled=false; cancelBtn.disabled=false; uploadBtn.disabled=false; goBtn.textContent=prev; busy=false; } };

             refresh();
         }
        
        // Make debugging functions globally available

        // Force a specific scenario for testing (overrides detection logic)

        function debugForceScenario(scenarioName) {

            window.forcedScenario = scenarioName;

            console.log(`🎭 Forced scenario to: ${scenarioName}`);

            updateButtonVisibilityFromMatrix() /* TODO: replace with state matrix */;

        }



        window.debugCurrentState = debugCurrentState;

        window.getVisibleButtons = getVisibleButtons;
        // Scenario-based globals removed; expose state matrix helpers instead



        window.updateButtonVisibilityFromMatrix = updateButtonVisibilityFromMatrix;

         
        
        // ===== Document dropdown helpers =====

        function toggleDocActionsMenu() {

            const menu = document.getElementById('docActionsMenu');

            if (!menu) return;

            const isShown = getComputedStyle(menu).display !== 'none';

            menu.style.display = isShown ? 'none' : 'block';

            if (!isShown) {

                // simple auto-close on outside click

                const onDocClick = (e) => {

                    const dropdown = document.getElementById('docActionsDropdown_grid') || document.getElementById('docActionsDropdown');

                    if (!menu || !dropdown) { document.removeEventListener('click', onDocClick); return; }

                    if (!menu.contains(e.target) && !dropdown.contains(e.target)) {

                        menu.style.display = 'none';

                        document.removeEventListener('click', onDocClick);

                    }

                };

                setTimeout(() => document.addEventListener('click', onDocClick), 0);

            }

        }



        // Mirror checkout status into the grid status bar whenever it changes

        const mirrorStatus = () => {

            const src = document.getElementById('checkoutStatus');

            const dst = document.getElementById('statusMirror');

            if (src && dst) dst.textContent = src.textContent || '—';

        };

        // Observe checkoutStatus text changes

        const statusEl = document.getElementById('checkoutStatus');

        if (statusEl) {

            const mo = new MutationObserver(mirrorStatus);

            mo.observe(statusEl, { characterData: true, subtree: true, childList: true });

            mirrorStatus();

        } else {

            // fallback after load

            window.addEventListener('load', mirrorStatus);

        }



        // ===== Users modal (Milestone 4) =====

        // Users modal deprecated in favor of inline table


        function closeUsersModal() {

            const modal = document.getElementById('usersModal');

            if (!modal) return;

            modal.style.display = 'none';

         }

         // Update individual user approval status from SSE (avoids API calls)
         function updateUserApprovalStatus(userId, newStatus) {
             console.log(`📊 WEB: Updating user ${userId} status to ${newStatus} (from SSE)`);
             
             // Find user row in modal table
             const modalTbody = document.getElementById('usersTableBody');
             if (!modalTbody) {
                 console.warn(`📊 WEB: usersTableBody not found - modal may not be open or populated`);
                 return;
             }
             console.log(`📊 WEB: Found modalTbody with ${modalTbody.querySelectorAll('tr').length} rows, looking for user row with data-user-id="${userId}"`);
             
             const userRow = modalTbody.querySelector(`tr[data-user-id="${userId}"]`);
             if (!userRow) {
                 console.warn(`📊 WEB: User row not found for ${userId} - available rows:`, Array.from(modalTbody.querySelectorAll('tr')).map(tr => ({
                     dataUserId: tr.getAttribute('data-user-id'),
                     textContent: tr.textContent.substring(0, 50)
                 })));
                 return;
             }
             console.log(`📊 WEB: Found user row for ${userId}, updating status...`);
             
             // Update status display
             const statusCell = userRow.querySelector('[data-col="status"]');
             if (statusCell) {
                 const isApproved = newStatus === 'approved';
                 const uiCfg = window.__approvalsUi || {};
                 const pill = isApproved
                   ? `<span style="display:inline-block;padding:2px 8px;border-radius:12px;font-size:12px;font-weight:600;color:${uiCfg?.colors?.pillApprovedText || '#155724'};background:${uiCfg?.colors?.pillApprovedBg || '#d4edda'};">${uiCfg?.labels?.approved || 'Approved'}</span>`
                   : newStatus === 'rejected'
                   ? `<span style="display:inline-block;padding:2px 8px;border-radius:12px;font-size:12px;font-weight:600;color:${uiCfg?.colors?.pillRejectedText || '#721c24'};background:${uiCfg?.colors?.pillRejectedBg || '#f8d7da'};">${uiCfg?.labels?.rejected || 'Rejected'}</span>`
                   : `<span style="display:inline-block;padding:2px 8px;border-radius:12px;font-size:12px;font-weight:600;color:#6c757d;background:#e9ecef;">${uiCfg?.labels?.no || 'No'}</span>`;
                 statusCell.innerHTML = pill;
             }
             
             // Update action buttons based on new status
             const actionsCell = userRow.querySelector('[data-col="actions"]');
             if (actionsCell) {
                 const buttons = actionsCell.querySelectorAll('button');
                 buttons.forEach(btn => {
                     if (btn.textContent.includes('Approve')) {
                         btn.disabled = newStatus === 'approved';
                     } else if (btn.textContent.includes('Reject')) {
                         btn.disabled = newStatus === 'rejected';
                     }
                 });
             }
         }

         // Quick pill update function for SSE sync (must be defined before SSE connects)
         function __updateApprovalsPillWeb(approved, total) {
             try {
                 console.log(`📊 WEB: __updateApprovalsPillWeb called with approved=${approved}, total=${total}`);
                 const pill = document.getElementById('approvalsPillWeb');
                 console.log(`📊 WEB: Found pill element:`, !!pill);
                 if (pill) {
                     const newText = `${approved || 0}/${total || 0} approved`;
                     console.log(`📊 WEB: Setting pill text to: "${newText}"`);
                     pill.textContent = newText;
                 } else {
                     console.warn('📊 WEB: Pill element not found');
                 }
             } catch (e) {
                 console.warn('📊 WEB: Failed to update approvals pill:', e);
             }
         }
         
         // Make pill update function globally available EARLY (before SSE connects)
         window.__updateApprovalsPillWeb = __updateApprovalsPillWeb;

         // Unified approvals refresh from server: fetch snapshot, update pill, then refresh modal
         // Unified: fetch state-matrix and approval-matrix, then apply to UI
         async function fetchUnifiedStateWeb() {
             try {
                 const actor = (window.currentUser && window.currentUser.id) ? window.currentUser : (getCurrentUser && getCurrentUser());
                 const actorId = actor && actor.id ? actor.id : null;
                 if (!actorId) return;
                 const currentId = (window.currentDocumentState && window.currentDocumentState.currentDocument && window.currentDocumentState.currentDocument.id) || 'default-doc';
                 const API_BASE = 'http://localhost:3001';
                 const [mxResp, apprResp] = await Promise.all([
                     fetch(`${API_BASE}/api/state-matrix?userRole=${encodeURIComponent(getCurrentUserRole())}&platform=web&userId=${encodeURIComponent(actorId)}`),
                     fetch(`${API_BASE}/api/approval-matrix?actorPlatform=web&actorId=${encodeURIComponent(actorId)}&documentId=${encodeURIComponent(currentId)}`)
                 ]);
                 const mxData = await mxResp.json();
                 const apprData = await apprResp.json();
                 if (mxData && mxData.success && apprData && apprData.success) {
                     applyUnifiedStateWeb({ matrixConfig: mxData.config, approvals: apprData });
                 }
             } catch (_) {}
         }

         function applyUnifiedStateWeb(unified) {
             try {
                 if (unified && unified.matrixConfig) {
                     window.__lastStateMatrix = unified.matrixConfig;
                     if (typeof window.applyStateMatrixToUI === 'function') {
                         window.applyStateMatrixToUI(unified.matrixConfig);
                     }
                 }
                 // Authoritative counts for top pill via approvals/state for the live document id
                 (async () => {
                     try {
                         const currentId = await getWebCurrentDocId();
                         console.log('WEB PILL: docId for approvals/state', currentId);
                         const st = await fetch(`http://localhost:3001/api/approvals/state?documentId=${encodeURIComponent(currentId)}`, { cache: 'no-store' }).then(r => r.json());
                          if (st && st.summary && typeof window.__updateApprovalsPillWeb === 'function') {
                              window.__updateApprovalsPillWeb(st.summary.approvedCount || 0, st.summary.totalUsers || 0);
                          }
                     } catch(_) {}
                 })();
                 try { refreshUsersModal(); } catch(_) {}
             } catch(_) {}
         }

         // Load initial approvals data for pill display (called on SSE connect)
         async function loadInitialApprovalsData() {
             try { window.ApprovalsUISyncWeb && window.ApprovalsUISyncWeb.refreshDebounced(); }
             catch (error) { console.error('📊 WEB: Error loading initial approvals data:', error); if (window.__updateApprovalsPillWeb) window.__updateApprovalsPillWeb(0, 0); }
         }

        async function refreshUsersModal() {

            try {
                console.log('WEB MODAL: start refreshUsersModal');
                let currentId = 'doc-current';
                try {
                    const doc = await fetch('http://localhost:3001/api/current-document', { cache: 'no-store' }).then(r => r.json());
                    currentId = (doc && (doc.id || doc.documentId)) ? (doc.id || doc.documentId) : 'doc-current';
                } catch(e) { console.warn('WEB MODAL: current-document failed', e); }
                console.log('WEB MODAL: docId =', currentId);
                const actor = (window.currentUser && window.currentUser.id) ? window.currentUser : (getCurrentUser && getCurrentUser());
                const actorId = actor && actor.id ? actor.id : null;
                const actorRole = actor && actor.role ? actor.role : (getCurrentUserRole && getCurrentUserRole());
                const isEditor = String(actorRole || '').toLowerCase() === 'editor';
                let matrixData = { matrix: {} };
                try {
                    const mr = await fetch(`http://localhost:3001/api/approval-matrix?actorPlatform=web&actorId=${encodeURIComponent(actorId || '')}&documentId=${encodeURIComponent(currentId)}`, { cache: 'no-store' });
                    matrixData = await mr.json();
                    console.log('WEB MODAL: matrix fetched (for flags only)', { ok: mr.ok, users: (matrixData.users||[]).length });
                } catch(e) { console.warn('WEB MODAL: matrix fetch failed (ignored)', e); }
                const sr = await fetch(`http://localhost:3001/api/approvals/state?documentId=${encodeURIComponent(currentId)}`, { cache: 'no-store' });
                const stateData = await sr.json();
                console.log('WEB MODAL: state fetched (authoritative roster)', { ok: sr.ok, approvers: (stateData.approvers||[]).length, summary: stateData.summary });
                const approvers = Array.isArray(stateData.approvers) ? stateData.approvers.slice().sort((a,b)=>a.order-b.order) : [];
                const matrix = matrixData.matrix || {};
                // Map by userId for status lookup
                const approvalMap = (approvers || []).reduce((acc, a) => { acc[a.userId] = a; return acc; }, {});
                const approvedCount = stateData && stateData.summary ? stateData.summary.approvedCount : approvers.filter(a => a.status === 'approved').length;
                const totalCount = approvers.length;
                const matrixUsers = Array.isArray(matrixData.users) ? matrixData.users : [];
                const modalTbody = document.getElementById('usersTableBody');
                const inlineTbody = document.getElementById('usersInlineBody');
                if (modalTbody) modalTbody.innerHTML = '';
                if (inlineTbody) inlineTbody.innerHTML = '';
                // Update header count e.g., "Users (1/3 approved)"
                const usersCardTitle = document.querySelector('.grid-card[style*="grid-column:1; grid-row:1;"] .grid-title');
                if (usersCardTitle) {
                    const ui = window.__approvalsUi;
                    const title = ui?.title || 'Approvals';
                    usersCardTitle.textContent = `${title}`;
                    if (ui?.colors?.title) usersCardTitle.style.color = ui.colors.title;
                }
                 // REMOVED: Local pill calculation to prevent race condition with SSE events
                 // Only SSE events should update the pill to ensure consistency
                 
                
                // Apply shared column headers
                const headerRow = document.getElementById('approvalsHeaderRowWeb');
                const ui = window.__approvalsUi;
                if (headerRow && ui?.columns) {
                    headerRow.querySelector('[data-col="user"]').textContent = ui.columns.user || 'User';
                    headerRow.querySelector('[data-col="role"]').textContent = ui.columns.role || 'Role';
                    headerRow.querySelector('[data-col="status"]').textContent = ui.columns.status || 'Approved';
                    headerRow.querySelector('[data-col="actions"]').textContent = ui.columns.actions || 'Actions';
                }
                approvers.forEach(a => {
                    const canonical = (matrixUsers || []).find(mu => mu.id === a.userId) || {};
                    const u = { id: a.userId, name: a.name || a.userId, role: canonical.role || '' };
                    const tr = document.createElement('tr');
                    tr.setAttribute('data-user-id', u.id);
                    tr.setAttribute('data-userid', u.id);
                    tr.setAttribute('data-user-name', u.name);
                    const row = matrix && matrix[u.id] ? matrix[u.id] : { status: 'no', showButtons: true, approveEnabled: true, rejectEnabled: true };
                    const status = (approvalMap[u.id] && approvalMap[u.id].status) || row.status || 'no';
                    const isApproved = status === 'approved';
                    const uiCfg = window.__approvalsUi;
                    const pill = isApproved
                      ? `<span style=\"display:inline-block;padding:2px 8px;border-radius:12px;font-size:12px;font-weight:600;color:${uiCfg?.colors?.pillApprovedText || '#155724'};background:${uiCfg?.colors?.pillApprovedBg || '#d4edda'};\">${uiCfg?.labels?.approved || 'Approved'}<\/span>`
                      : `<span style=\"display:inline-block;padding:2px 8px;border-radius:12px;font-size:12px;font-weight:600;color:${uiCfg?.colors?.pillRejectedText || '#721c24'};background:${uiCfg?.colors?.pillRejectedBg || '#f8d7da'};\">${status === 'rejected' ? (uiCfg?.labels?.rejected || 'Rejected') : (uiCfg?.labels?.no || 'No')}<\/span>`;
                    tr.innerHTML = `

                         <td data-col=\"user\" style=\"padding:8px; border-bottom:1px solid #f1f3f5;\">${u.name}</td>
                         <td data-col=\"role\" style=\"padding:8px; border-bottom:1px solid #f1f3f5;\">${u.role}</td>
                         <td data-col=\"status\" style=\"padding:8px; border-bottom:1px solid #f1f3f5; white-space:nowrap;\">${pill}</td>
                         <td data-col=\"actions\" style=\"padding:8px; border-bottom:1px solid #f1f3f5;\">
                            ${row.showButtons ? `
                                <div style=\\\"display:flex; gap:6px;\\\">`
 +
 `
                                    <button class=\\\"btn\\\" ${(row.approveEnabled && !isApproved) ? '' : 'disabled'} data-action=\\\"approve\\\" data-user=\\\"${u.id}\\\" data-status=\\\"${status}\\\">Approve</button>

                                    <button class=\\\"btn\\\" ${(row.rejectEnabled && status !== 'rejected') ? '' : 'disabled'} data-action=\\\"reject\\\" data-user=\\\"${u.id}\\\" data-status=\\\"${status}\\\">Reject</button>

                                </div>

                            ` : `<span style=\\\"opacity:.6; font-size:12px;\\\">No actions</span>`}

                        </td>

                     `;
                     if (modalTbody) {
                         modalTbody.appendChild(tr);
                         console.log('🔍 WEB: Created row for user:', u.name, {
                             showButtons: row.showButtons,
                             status: status,
                             isApproved: isApproved,
                             buttonsInHTML: tr.innerHTML.includes('data-action="approve"')
                         });
                         // styling retained below
                     }
                });
                // Bind click handlers to update state and re-render
                const bindActions = (root) => {
                     const buttons = (root || document).querySelectorAll('button[data-user]');
                     console.log('🔍 WEB: Found approval buttons for binding:', buttons.length);
                     // Debugging removed - buttons now working with inline styling fix
                     buttons.forEach(btn => {
                        btn.addEventListener('click', async (e) => {

                             console.log('🎯 WEB: Approval button clicked!', {
                                 button: e.target,
                                 dataUser: btn.getAttribute('data-user'),
                                 dataAction: btn.getAttribute('data-action'),
                                 dataStatus: btn.getAttribute('data-status')
                             });
                             
                            const targetUserId = btn.getAttribute('data-user');

                            const explicitAction = btn.getAttribute('data-action');

                            const currentStatus = btn.getAttribute('data-status');

                            const nextAction = explicitAction || (currentStatus === 'approved' ? 'reject' : 'approve');

                            // Warn if acting on behalf of someone else and current user is editor

                            // Server-driven confirm: read matrix for confirmation rules and string

                            try {

                                const actor = (window.currentUser && window.currentUser.id) ? window.currentUser : (getCurrentUser && getCurrentUser());

                                const currentId = (window.currentDocumentState && window.currentDocumentState.currentDocument && window.currentDocumentState.currentDocument.id) || 'default-doc';

                                const mxResp = await fetch(`http://localhost:3001/api/approval-matrix?actorPlatform=web&actorId=${encodeURIComponent(actor.id)}&documentId=${encodeURIComponent(currentId)}`);

                                const mx = await mxResp.json();

                                const row = mx && mx.matrix ? mx.matrix[targetUserId] : null;

                                if (row && row.needsConfirm) {

                                    const strings = (mx && mx.strings) || {};

                                    const tmpl = strings[row.confirmMessageKey || 'confirmActOnBehalf'] || 'You are about to {action} on behalf of {targetName}. Continue?';

                                    const target = (mx.users || []).find(u => u.id === targetUserId);

                                    const ask = tmpl.replace('{action}', nextAction).replace('{targetName}', target ? target.name : 'this user');

                                    const ok = window.confirm(ask);

                                    if (!ok) return;

                                }

                            } catch(_) {}

                            try {

                                const currentId = (window.currentDocumentState && window.currentDocumentState.currentDocument && window.currentDocumentState.currentDocument.id) || 'default-doc';

                                 
                                 console.log('🚀 WEB: Making approval API call', {
                                     userId: targetUserId,
                                     action: nextAction,
                                     actorId: (window.currentUser && window.currentUser.id) || 'user1',
                                     documentId: currentId
                                 });
                                 
                                if (nextAction === 'approve') {
                                  await ApprovalsClient.approve({ documentId: currentId, targetUserId: targetUserId, actorId: (window.currentUser && window.currentUser.id) || 'user1' });
                                } else {
                                  await ApprovalsClient.reject({ documentId: currentId, targetUserId: targetUserId, actorId: (window.currentUser && window.currentUser.id) || 'user1', comment: '' });
                                }

                            } catch (err) {

                                console.warn('WEB: approval toggle failed', err);

                            } finally {

                                try { await refreshUsersModal(); } catch (_) {}

                            }

                        });

                    });

                };

                if (inlineTbody) bindActions(inlineTbody);

                if (modalTbody) bindActions(modalTbody);

                console.log('WEB MODAL: end refreshUsersModal');
            } catch (err) {
                console.error('WEB MODAL: refreshUsersModal failed', err);
                addNotification('Error loading users/approvals', 'error');
            }

        }



        // Debug notification location

        window.debugNotificationLocation = function() {

            console.log('🔍 DEBUGGING NOTIFICATION LOCATION:');

             
            
            // Check main container

            const mainContainer = document.querySelector('.main-content-3col');

            console.log('📦 main-content-3col element:', mainContainer);

            if (mainContainer) {

                const styles = window.getComputedStyle(mainContainer);

                console.log('📦 main-content-3col display:', styles.display);

                console.log('📦 main-content-3col flex-direction:', styles.flexDirection);

                console.log('📦 main-content-3col location:', mainContainer.getBoundingClientRect());

            }

             
            
            // Check right column

            const rightCol = document.querySelector('.main-content-3col .right-column');

            console.log('📦 right-column element:', rightCol);

            if (rightCol) {

                const styles = window.getComputedStyle(rightCol);

                console.log('📦 right-column display:', styles.display);

                console.log('📦 right-column width:', styles.width);

                console.log('📦 right-column flex-shrink:', styles.flexShrink);

                console.log('📦 right-column location:', rightCol.getBoundingClientRect());

            }

             
            
            // Check notification window body

            const windowBody = document.getElementById('notificationWindowBody');

            console.log('📦 notificationWindowBody element:', windowBody);

            if (windowBody) {

                console.log('📦 notificationWindowBody parent:', windowBody.parentElement);

                console.log('📦 notificationWindowBody grandparent:', windowBody.parentElement?.parentElement);

                console.log('📦 notificationWindowBody position:', window.getComputedStyle(windowBody).position);

                console.log('📦 notificationWindowBody location:', windowBody.getBoundingClientRect());

            }

        };



        // Test 1: Check for CSS rule conflicts

        window.testCSSCascade = function() {

            console.log('🔍 TEST 1: CSS Cascade/Inheritance Analysis');

             
            
            const mainEl = document.querySelector('.main-content-3col');

            const rightEl = document.querySelector('.main-content-3col .right-column');

             
            
            // Check all CSS rules that apply to our elements

            const mainStyles = window.getComputedStyle(mainEl);

            const rightStyles = window.getComputedStyle(rightEl);

             
            
            console.log('📋 Main container CSS:');

            console.log('  display:', mainStyles.display);

            console.log('  flex-direction:', mainStyles.flexDirection);

            console.log('  gap:', mainStyles.gap);

             
            
            console.log('📋 Right column CSS:');

            console.log('  display:', rightStyles.display);

            console.log('  width:', rightStyles.width);

            console.log('  flex-shrink:', rightStyles.flexShrink);

             
            
            // Check for conflicting selectors

            const allStyleSheets = Array.from(document.styleSheets);

            console.log('📄 Found', allStyleSheets.length, 'stylesheets');

             
            
            // Look for rules that might conflict

            try {

                allStyleSheets.forEach((sheet, i) => {

                    console.log(`📄 Stylesheet ${i}:`, sheet.href || 'inline');

                });

            } catch(e) {

                console.log('⚠️ Cannot access some stylesheets (CORS)');

            }

        };



        // Test 2: Check inheritance and default styles

        window.testBlockInheritance = function() {

            console.log('🔍 TEST 2: Block Display Inheritance Analysis');

             
            
            const mainEl = document.querySelector('.main-content-3col');

            const leftEl = document.querySelector('.left-column.buttons-column');

            const centerEl = document.querySelector('.center-column.title-banner-column');

            const rightEl = document.querySelector('.main-content-3col .right-column');

             
            
            console.log('📋 Element hierarchy display values:');

            console.log('  main-content-3col:', window.getComputedStyle(mainEl).display);

            console.log('  left-column:', window.getComputedStyle(leftEl).display);

            console.log('  center-column:', window.getComputedStyle(centerEl).display);

            console.log('  right-column:', window.getComputedStyle(rightEl).display);

             
            
            console.log('📋 Testing CSS rule application:');

            // Try to manually apply styles and see what happens

            mainEl.style.display = 'flex';

            mainEl.style.flexDirection = 'row';

            rightEl.style.width = '300px';

            rightEl.style.flexShrink = '0';

             
            
            setTimeout(() => {

                console.log('📋 After manual style application:');

                console.log('  main display:', window.getComputedStyle(mainEl).display);

                console.log('  right width:', window.getComputedStyle(rightEl).width);

                console.log('  right location:', rightEl.getBoundingClientRect());

            }, 100);

        };



        // Test 3: Check CSS parsing integrity

        // Debug SuperDoc container visibility

        window.debugSuperdocContainer = function() {

            console.log('🔍 DEBUGGING SUPERDOC CONTAINER:');

             
            
            const container = document.querySelector('#superdoc');

            console.log('📦 SuperDoc container element:', container);

             
            
            if (container) {

                const styles = window.getComputedStyle(container);

                const rect = container.getBoundingClientRect();

                 
                
                console.log('📦 Container styles:');

                console.log('  display:', styles.display);

                console.log('  visibility:', styles.visibility);

                console.log('  opacity:', styles.opacity);

                console.log('  width:', styles.width);

                console.log('  height:', styles.height);

                console.log('  overflow:', styles.overflow);

                console.log('  position:', styles.position);

                console.log('  z-index:', styles.zIndex);

                 
                
                console.log('📦 Container location:');

                console.log('  x:', rect.x, 'y:', rect.y);

                console.log('  width:', rect.width, 'height:', rect.height);

                console.log('  top:', rect.top, 'bottom:', rect.bottom);

                 
                
                console.log('📦 Container content:');

                console.log('  innerHTML length:', container.innerHTML.length);

                console.log('  children count:', container.children.length);

                 
                
                if (container.children.length > 0) {

                    console.log('  first child:', container.children[0]);

                }

            }

             
            
            // Check parent container

            const viewerContainer = document.querySelector('.viewer-container');

            console.log('📦 Viewer container element:', viewerContainer);

             
            
            if (viewerContainer) {

                const styles = window.getComputedStyle(viewerContainer);

                const rect = viewerContainer.getBoundingClientRect();

                console.log('📦 Viewer container location:', rect);

                console.log('📦 Viewer container display:', styles.display);

            }

        };



        window.testCSSParsing = function() {

            console.log('🔍 TEST 3: CSS Syntax/Parsing Analysis');

             
            
            // Check if our CSS rules exist in the document

            const styleElements = document.querySelectorAll('style');

            console.log('📄 Found', styleElements.length, 'style elements');

             
            
            styleElements.forEach((style, i) => {

                const cssText = style.textContent;

                console.log(`📄 Style block ${i} length:`, cssText.length, 'characters');

                 
                
                // Check if our specific rules exist

                const hasMainContent3Col = cssText.includes('.main-content-3col');

                const hasRightColumn = cssText.includes('.main-content-3col .right-column');

                 
                
                console.log(`  Contains .main-content-3col: ${hasMainContent3Col}`);

                console.log(`  Contains right-column rule: ${hasRightColumn}`);

                 
                
                // Check for common syntax errors

                const openBraces = (cssText.match(/\{/g) || []).length;

                const closeBraces = (cssText.match(/\}/g) || []).length;

                console.log(`  Braces balance: ${openBraces} open, ${closeBraces} close`);

                 
                
                if (openBraces !== closeBraces) {

                    console.log('⚠️ BRACE MISMATCH DETECTED!');

                }

            });

             
            
            // Test if we can inject working CSS

            const testStyle = document.createElement('style');

            testStyle.textContent = `

                .css-test-element { color: red; font-weight: bold; }

            `;

            document.head.appendChild(testStyle);

             
            
            const testDiv = document.createElement('div');

            testDiv.className = 'css-test-element';

            testDiv.textContent = 'CSS Test';

            document.body.appendChild(testDiv);

             
            
            setTimeout(() => {

                const testColor = window.getComputedStyle(testDiv).color;

                console.log('🧪 CSS injection test color:', testColor);

                console.log(testColor === 'rgb(255, 0, 0)' ? '✅ CSS parsing works' : '❌ CSS parsing broken');

                 
                
                // Cleanup

                testStyle.remove();

                testDiv.remove();

            }, 100);

        };

         
        
        // Load default document function

        async function loadDefaultDocumentIfAvailable() {

            try {

                console.log('📄 Loading default document...');

                console.log('🔗 Calling API: http://localhost:3001/api/default-document');

                 
                
                const response = await fetch('http://localhost:3001/api/default-document');

                console.log('📡 API Response status:', response.status);

                 
                
                if (response.ok) {

                    const documentData = await response.json();

                    console.log('📄 Document data received:', documentData);

                     
                    
                    // Update document title

                    const titleElement = document.getElementById('document-title');

                    if (titleElement && documentData.filename) {

                        titleElement.textContent = documentData.filename;

                    }

                     
                    
                    // Load the document in SuperDoc

                    console.log('📄 Attempting SuperDoc load for:', documentData.filename);

                    await loadSuperdoc(documentData);
                    
                     
                    
                } else {

                    console.log('❌ Failed to load default document:', response.status);

                }

            } catch (error) {

                console.log('❌ Error loading default document:', error);

            }

        }

         
        
        // Load SuperDoc function

        async function loadSuperdoc(documentData) {

            try {

                // Check if SuperDoc is available

                const SuperDocLib = window.SuperDocLibrary;

                const SuperDocToUse = SuperDocLib?.SuperDoc || SuperDocLib?.default || SuperDocLib;

                 
                
                if (!SuperDocToUse) {

                    console.log('❌ SuperDoc not available');

                    console.log('🔍 SuperDocLibrary contents:', Object.keys(SuperDocLib || {}));

                    return;

                }

                 
                
                console.log('✅ SuperDoc found, initializing...');

                console.log('📋 Document data:', documentData);

                console.log('📋 Current user:', currentUser);

                 
                
                // Clear the container first

                const container = document.querySelector('#superdoc');

                if (container) {

                    container.innerHTML = '';

                    console.log('🧹 Cleared SuperDoc container');

                }

                 
                
                // Initialize SuperDoc with the document

                const documentUrl = `http://localhost:3001/api/document/${documentData.id}`;

                console.log('🔗 SuperDoc will fetch document from:', documentUrl);

                 
                
                // Determine correct mode and user role based on current user

                const userRole = currentUser?.role || 'viewer';

                const documentMode = getSuperdocMode(userRole);

                const superdocUserRole = getSuperdocUserRole(userRole);

                console.log('🎭 User role:', userRole, '-> SuperDoc mode:', documentMode, '-> SuperDoc userRole:', superdocUserRole);

                 
                
                const superdoc = new SuperDocToUse({

                    selector: '#superdoc',

                    toolbar: '#superdoc-toolbar',

                    pagination: true,

                    document: {

                        id: documentData.id,

                        type: 'docx',

                        url: documentUrl  // Use URL instead of data for remote documents

                    },

                    documentMode: documentMode,

                    role: superdocUserRole, // Use 'role' at top level according to official docs

                    licenseKey: 'agplv3',

                    modules: {

                        comments: {

                            readOnly: documentMode === 'viewing', // Read-only comments for viewers

                            allowResolve: documentMode !== 'viewing' // Allow resolving comments for editors/suggesters

                        }

                    },

                    user: {

                        name: currentUser?.name || 'Unknown User',

                        id: currentUser?.id || 'unknown'

                        // No role property in user object according to docs

                    }

                });

                 
                
                console.log('✅ SuperDoc initialized successfully');

                console.log('📋 SuperDoc instance:', superdoc);

                console.log('🔍 SuperDoc config - documentMode:', superdoc.config?.documentMode);

                console.log('🔍 SuperDoc config - role:', superdoc.config?.role);

                console.log('🔍 SuperDoc config - modules:', superdoc.config?.modules);

                 
                
                // Store globally and locally for testing

                window.currentSuperdoc = superdoc;

                currentSuperdoc = superdoc;

                 
                
                // Add comprehensive event listeners

                superdoc.on('ready', () => {

                    console.log('🎉 SuperDoc is ready and loaded');

                });

                 
                
                superdoc.on('loaded', () => {

                    console.log('📄 SuperDoc document loaded');

                });

                 
                
                superdoc.on('error', (error) => {

                    console.log('❌ SuperDoc error:', error);

                });

                 
                
                superdoc.on('document-loaded', () => {

                    console.log('📄 SuperDoc document-loaded event');

                });

                 
                
                superdoc.on('document-error', (error) => {

                    console.log('❌ SuperDoc document-error:', error);

                });

                 
                
                // Add more comprehensive event listeners

                superdoc.on('loading', () => {

                    console.log('⏳ SuperDoc loading event');

                });

                 
                
                superdoc.on('load-failed', (error) => {

                    console.log('❌ SuperDoc load-failed:', error);

                });

                 
                
                superdoc.on('document-load-failed', (error) => {

                    console.log('❌ SuperDoc document-load-failed:', error);

                });

                 
                
                superdoc.on('fetch-failed', (error) => {

                    console.log('❌ SuperDoc fetch-failed:', error);

                });

                 
                
                // Add a timeout to check if document actually loads

                setTimeout(() => {

                    console.log('⏰ SuperDoc status check after 3 seconds:');

                    const container = document.querySelector('#superdoc');

                    console.log('   Container content length:', container.innerHTML.length);

                    console.log('   Container HTML preview:', container.innerHTML.substring(0, 200) + '...');

                    console.log('   SuperDoc state:', {

                        ready: superdoc.ready,

                        loaded: superdoc.loaded,

                        document: superdoc.document

                    });

                     
                    
                    // Check if there's a document loading error in SuperDoc

                    console.log('🔍 Checking SuperDoc internals:');

                    console.log('   SuperDoc version:', superdoc.version);

                    console.log('   SuperDoc methods:', Object.getOwnPropertyNames(superdoc).slice(0, 10));

                     
                    
                    // Test the exact URL SuperDoc is using

                    console.log('🧪 Testing document URL that SuperDoc should be using...');

                    fetch(documentUrl)

                        .then(response => {

                            console.log('📡 Direct fetch test - Status:', response.status);

                            console.log('📡 Direct fetch test - Content-Type:', response.headers.get('content-type'));

                            console.log('📡 Direct fetch test - Content-Length:', response.headers.get('content-length'));

                            return response.blob();

                        })

                        .then(blob => {

                            console.log('📄 Direct fetch test - Blob size:', blob.size, 'bytes');

                            console.log('📄 Direct fetch test - Blob type:', blob.type);

                        })

                        .catch(error => {

                            console.log('❌ Direct fetch test - Error:', error);

                        });

                }, 3000);
                
                 
                
            } catch (error) {

                console.log('❌ Error initializing SuperDoc:', error);

                console.log('📋 Error details:', error.message, error.stack);

            }

        }

         
        
        // ===== END MILESTONE 1 STATE DETECTION =====

         
        
        // Initialize web viewer

        window.addEventListener('load', () => {

            console.log('OpenGov Contract Redlining Web Viewer initialized');
            
             // Initialize user system FIRST to ensure approvals data loads correctly
             console.log('Initializing user system first...');
            setTimeout(async () => {

                await initializeUserSystem();

                 
                 // Connect SSE AFTER user system is ready
                 console.log('User system ready, connecting to SSE...');
                 connectSSE();
                fetchDocumentStatus();

                 // Fixed timing: populate dropdown BEFORE hiding legacy buttons
                 setTimeout(async () => {
                     console.log('🔄 UI CONSOLIDATION FIX: Syncing web state matrix and dropdowns...');
                     
                     // Step 1: Get state matrix config
                     try { 
                         await updateUIFromStateMatrix('web', getCurrentUser, getCurrentUserRole, currentDocumentState); 
                     } catch(e) { 
                         console.warn('Web state matrix update failed:', e); 
                     }
                     
                     // Step 2: Immediately populate dropdown with matrix config
                     if (window.__lastStateMatrix) {
                         try {
                             if (window.refreshActionsDropdownFromMatrix) {
                                 window.refreshActionsDropdownFromMatrix('webDocActionsSelect', window.__lastStateMatrix);
                             }
                         } catch(e) { console.warn('Web dropdown population failed:', e); }
                     }
                     
                     console.log('✅ UI CONSOLIDATION: Web state matrix and dropdowns synchronized');
                }, 50);

                // Populate inline users table on load

                try { await refreshUsersModal(); } catch (e) { /* ignore */ }

                 
                
                // Load default document

                await loadDefaultDocumentIfAvailable();

                // Refresh inline users again after default doc to ensure approvals count

                try { await refreshUsersModal(); } catch (e) { /* ignore */ }

                 
                
                // Make test functions available globally after initialization

                window.testUserSystem = testUserSystem;

                window.debugUserState = debugUserState;

                 
                
                // Also add direct access functions

                window.switchToUser2 = () => switchUser('user2');

                window.switchToUser1 = () => switchUser('user1');

                window.overrideCheckout = overrideCheckout; window.checkUserState = () => console.log('Current user:', currentUser, 'Can edit:', canCurrentUserEdit());

                 
                
                console.log('🧪 Test functions ready!');

                console.log('Try: testUserSystem(), debugUserState(), switchToUser2(), checkUserState()');

                console.log('🎭 Try: testRoleMapping(), testSuperdocMode(), testRoleSwitching()');

                 
                
                // Show current user state

                if (currentUser) {

                    console.log('👤 Current user loaded:', currentUser.name, `(${currentUser.role})`);

                }

                 
                
                // Test role mapping function

                window.testRoleMapping = function() {

                    console.log('🧪 Testing role mapping:');

                    const roles = ['editor', 'suggester', 'viewer', 'vendor'];

                    roles.forEach(role => {

                        const mode = getSuperdocMode(role);

                        console.log(`  ${role} -> ${mode}`);

                    });

                     
                    
                    const currentRole = getCurrentUserRole();

                    const expectedMode = getSuperdocMode(currentRole);

                    console.log(`  Current: ${currentRole} -> ${expectedMode}`);

                     
                    
                    return { currentRole, expectedMode };

                };

                 
                
                // Test SuperDoc mode function

                window.testSuperdocMode = function() {

                    console.log('🧪 Testing SuperDoc mode:');

                    const superdoc = window.currentSuperdoc;

                    if (!superdoc) {

                        console.log('  ❌ No SuperDoc instance found');

                        return { error: 'No SuperDoc instance' };

                    }

                     
                    
                    const currentRole = getCurrentUserRole();

                    const expectedMode = getSuperdocMode(currentRole);

                     
                    
                    // Try different methods to get the mode  

                    const methods = [

                        'getDocumentMode',

                        'getMode', 

                        'mode',

                        'documentMode',

                        'config.documentMode',

                        'config.mode',

                        'options.documentMode',

                        'document.mode'

                    ];

                     
                    
                    console.log('🔍 Testing SuperDoc mode methods:');

                    let actualMode = 'unknown';

                    methods.forEach(method => {

                        try {

                            let value;

                            if (method.includes('.')) {

                                const parts = method.split('.');

                                value = superdoc[parts[0]]?.[parts[1]];

                            } else {

                                value = typeof superdoc[method] === 'function' ? superdoc[method]() : superdoc[method];

                            }

                            console.log(`    ${method}: ${value}`);

                            if (value && value !== 'unknown' && actualMode === 'unknown') {

                                actualMode = value;

                            }

                        } catch (e) {

                            console.log(`    ${method}: error - ${e.message}`);

                        }

                    });

                     
                    
                    // Note: Do not toggle mode after init; we set mode at initialization for stability

                     
                    
                    console.log(`  User role: ${currentRole}`);

                    console.log(`  Expected mode: ${expectedMode}`);

                    console.log(`  Actual mode: ${actualMode}`);

                    console.log(`  Match: ${expectedMode === actualMode ? '✅' : '❌'}`);

                     
                    
                    return { currentRole, expectedMode, actualMode, match: expectedMode === actualMode };

                };

                 
                
                // Test SuperDoc UI elements to see mode differences

                window.inspectSuperdocUI = function() {

                    console.log('🔍 Inspecting SuperDoc UI elements for mode differences:');

                    const container = document.querySelector('#superdoc');

                    const toolbar = document.querySelector('#superdoc-toolbar');

                     
                    
                    if (!container) {

                        console.log('❌ SuperDoc container not found');

                        return;

                    }

                     
                    
                    // Look for ProseMirror editor specifically

                    const prosemirror = container.querySelector('.ProseMirror');

                    if (prosemirror) {

                        console.log('✏️ ProseMirror editor found:');

                        console.log('   Classes:', prosemirror.className);

                        console.log('   Contenteditable:', prosemirror.contentEditable);

                         
                        
                        // Test if we can actually edit

                        console.log('🧪 Testing editability:');

                        try {

                            prosemirror.focus();

                            console.log('   Can focus: ✅');

                        } catch (e) {

                            console.log('   Can focus: ❌', e.message);

                        }

                    }

                     
                    
                    // Check toolbar contents

                    if (toolbar) {

                        const toolbarButtons = toolbar.querySelectorAll('button, [role="button"]');

                        console.log(`🛠️ Toolbar found with ${toolbarButtons.length} buttons:`);

                        toolbarButtons.forEach((btn, i) => {

                            if (i < 15) { // Show first 15 buttons

                                const text = btn.textContent || btn.title || btn.getAttribute('aria-label') || 'No label';

                                console.log(`   ${i + 1}. ${text.trim()}`);

                            }

                        });

                         
                        
                        // Check for disabled buttons

                        const disabledButtons = toolbar.querySelectorAll('button[disabled], [role="button"][disabled]');

                        console.log(`🚫 Found ${disabledButtons.length} disabled buttons`);

                    } else {

                        console.log('❌ Toolbar not found');

                    }

                     
                    
                    // Check current role and mode

                    const currentRole = getCurrentUserRole();

                    const expectedMode = getSuperdocMode(currentRole);

                    const actualMode = window.currentSuperdoc?.config?.documentMode || 'unknown';

                     
                    
                    console.log(`🎭 Current role: ${currentRole}`);

                    console.log(`🎭 Expected mode: ${expectedMode}`);

                    console.log(`🎭 Actual mode: ${actualMode}`);

                     
                    
                    return {

                        currentRole,

                        expectedMode,

                        actualMode,

                        toolbarButtons: toolbar ? toolbar.querySelectorAll('button, [role="button"]').length : 0,

                        prosemirrorEditable: prosemirror?.contentEditable === 'true'

                    };

                };



                // Test role switching with mode verification

                window.testRoleSwitching = function() {

                    console.log('🧪 Testing role switching with SuperDoc mode changes:');

                     
                    
                    const testSequence = async () => {

                        // Test suggester

                        console.log('1️⃣ Switching to suggester...');

                        switchUser('user5'); // Yuri Lee Laffed (suggester)

                         
                        
                        setTimeout(() => {

                            console.log('🔍 Testing suggester mode:');

                            testSuperdocMode();

                             
                            
                            // Test editor  

                            console.log('2️⃣ Switching to editor...');

                            switchUser('user1'); // Warren Peace (editor)

                             
                            
                            setTimeout(() => {

                                console.log('🔍 Testing editor mode:');

                                testSuperdocMode();

                                 
                                
                                // Test viewer

                                console.log('3️⃣ Switching to viewer...');

                                switchUser('user2'); // Gettysburger King (viewer)

                                 
                                
                                setTimeout(() => {

                                    console.log('🔍 Testing viewer mode:');

                                    testSuperdocMode();

                                }, 2000);

                            }, 2000);

                        }, 2000);

                    };

                     
                    
                    testSequence();

                };

                 
                
                // Debug function to test checkout banner colors

                window.debugCheckoutColors = function() {

                     console.log('🎨 WEB VIEWER Banner Color Debug:');
                    const banner = document.getElementById('checkoutStatus');

                    if (!banner) {

                        console.log('❌ Checkout banner not found');

                        return;

                    }

                     
                    
                    console.log('📋 Banner element:', banner);

                    console.log('📝 Current text:', banner.textContent);

                    console.log('🎨 Current classes:', banner.classList.toString());

                    console.log('🖌️ Computed background color:', getComputedStyle(banner).backgroundColor);

                     console.log('🖌️ Expected: Available=#bfdbfe, Checked-out=#3b82f6');
                     
                     // Test unified blue colors
                     console.log('🧪 Testing unified blue colors:');
                     banner.style.backgroundColor = '#bfdbfe';
                     banner.style.color = '#1e40af';
                     banner.style.padding = '6px 11px';
                    banner.style.borderRadius = '4px';

                     console.log('🔵 Applied unified available light blue (#bfdbfe)');
                     console.log('🖌️ Background after unified style:', getComputedStyle(banner).backgroundColor);
                     
                    
                    setTimeout(() => {

                         banner.style.backgroundColor = '#3b82f6';
                         banner.style.color = 'white';
                         console.log('🔵 Applied unified checked-out medium blue (#3b82f6)');
                         console.log('🖌️ Background after checked-out blue:', getComputedStyle(banner).backgroundColor);
                         
                        
                        setTimeout(() => {

                            banner.style.backgroundColor = '';

                            console.log('🧪 Removed forced styles');

                            console.log('🖌️ Background after reset:', getComputedStyle(banner).backgroundColor);

                        }, 2000);

                    }, 2000);

                };

            }, 1000); // Small delay to ensure SSE connection is established

        });

    </script>

     
     <!-- Take Me Back to OpenGov Modal -->
     <div id="backToOpenGovModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 2147483647;">
         <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; border-radius: 8px; padding: 20px; max-width: 90vw; max-height: 90vh; box-shadow: 0 4px 20px rgba(0,0,0,0.15);">
             <h2 style="margin: 0 0 15px 0; font-size: 18px; font-weight: 600; text-align: center;">We're not going back! We're going forward!</h2>
             <div style="position: relative; width: 560px; height: 315px; max-width: 100%;">
                 <iframe id="backToOpenGovVideo" 
                         width="560" 
                         height="315" 
                         src="" 
                         data-src="https://www.youtube.com/embed/dQw4w9WgXcQ?autoplay=1&mute=0" 
                         title="YouTube video player" 
                         frameborder="0" 
                         allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" 
                         allowfullscreen>
                 </iframe>
             </div>
         </div>
     </div>
     
     <script>
         // Take Me Back to OpenGov modal functionality (explicit global API to avoid misbinding)
         (function(){
             const modal = document.getElementById('backToOpenGovModal');
             const video = document.getElementById('backToOpenGovVideo');
             function stopVideo(){ if(video) video.src = ''; }
             window.openOpenGovModal = function openOpenGovModal(){
                 try { window.closeAllModals && window.closeAllModals(); } catch(_) {}
                 if (modal) {
                     // Set src BEFORE opening for guaranteed first-paint
                     if (video) { video.src = video.getAttribute('data-src') || video.src || ''; }
                     if (typeof window.openModalById === 'function') {
                         window.openModalById('backToOpenGovModal');
                     } else {
                         modal.style.display = 'block';
                     }
                 }
             };
             window.closeOpenGovModal = function closeOpenGovModal(){
                 if (modal) modal.style.display = 'none';
                 stopVideo();
             };
             if (modal) {
                 modal.addEventListener('click', function(e){ if (e.target === modal) window.closeOpenGovModal(); });
                 document.addEventListener('keydown', function(e){ if (e.key === 'Escape' && modal.style.display === 'block') window.closeOpenGovModal(); });
             }
         })();
     </script>
     
    <script src="state-matrix-client.js"></script>
    <script src="shared/approvals-client.js"></script>

    <script src="state-matrix-tests.js"></script>

    <!-- Approvals Modal (Web) -->
    <div id="approvalsModalWeb" style="display:none; position:fixed; inset:0; z-index:2147483647;">
        <div style="position:absolute; inset:0; background:rgba(0,0,0,0.5);"></div>
        <div style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); width:min(900px,92vw); max-height:88vh; overflow:auto; background:#fff; border-radius:8px; box-shadow:0 10px 30px rgba(0,0,0,0.25);">
            <div style="display:flex; align-items:center; justify-content:space-between; padding:14px 18px; border-bottom:1px solid #e5e7eb;">
                <div style="font-weight:600; font-size:16px;">Approvals <span id="approvalsSummaryWeb" style="font-weight:500; color:#374151; margin-left:6px;"></span></div>
                
            </div>
            <style>
                #approvalsModalWeb .btn { background:#374151 !important; color:#fff !important; border:none !important; border-radius:6px !important; padding:8px 12px !important; cursor:pointer; }
                #approvalsModalWeb .btn-secondary { background:#bfdbfe !important; color:#1e40af !important; }
                #approvalsModalWeb .btn-danger { background:#dc2626 !important; color:#fff !important; }
                #approvalsModalWeb .btn-trash { background:#dc2626 !important; color:#fff !important; border:1px solid #b91c1c !important; padding:2px 4px !important; line-height:1 !important; border-radius:4px !important; }
                #approvalsModalWeb .btn-ghost { background:transparent !important; color:#374151 !important; border:1px solid #e5e7eb !important; }
                #approvalsModalWeb table { width:100%; border-collapse:collapse; }
                #approvalsModalWeb th, #approvalsModalWeb td { border-bottom:1px solid #e5e7eb; padding:8px 10px; text-align:left; }
                #approvalsModalWeb th { background:#f9fafb; font-weight:600; position:sticky; top:0; z-index:1; }
                #approvalsModalWeb input[type="number"] { width:64px; padding:6px 8px; border:1px solid #e5e7eb; border-radius:6px; }
                #approvalsModalWeb input[type="text"], #approvalsModalWeb textarea { width:100%; padding:6px 8px; border:1px solid #e5e7eb; border-radius:6px; }
                #approvalsModalWeb .icon-trash { display:inline-block; transform: scale(0.5, 0.7); transform-origin:center; }
            </style>
            <div id="approvalsFooterWeb" style="padding:14px 18px; display:flex; justify-content:space-between; gap:8px; align-items:center; border-top:1px solid #e5e7eb; margin-top:8px; position:sticky; bottom:0; background:#fff;">
                <div style="display:flex; gap:8px; align-items:center;">
                    <button id="approvalsAddUserWeb" class="btn btn-secondary" style="display:none;">Add user</button>
                    <button id="approvalsRefreshWeb" class="btn btn-ghost">Refresh</button>
                    <button id="approvalsResetWeb" class="btn btn-danger" style="display:none;">Nuke it</button>
                </div>
                <div>
                    <button id="approvalsCloseWeb" class="btn btn-ghost">Close</button>
                </div>
            </div>
            <div id="approvalsBodyWeb" style="padding:0 18px 18px 18px;"></div>
        </div>
    </div>

    <script>
        (function(){
            const modal = document.getElementById('approvalsModalWeb');
            const closeBtn = document.getElementById('approvalsCloseWeb');
            if (closeBtn) closeBtn.addEventListener('click', () => { modal.style.display='none'; });
            if (modal) modal.addEventListener('click', (e) => { if (e.target === modal) modal.style.display='none'; });
            document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && modal && modal.style.display==='block') modal.style.display='none'; });
        })();

        async function getWebActorId() {
            try {
                const r = await fetch('http://localhost:3001/api/user/web/current', { cache:'no-store' });
                const j = await r.json();
                return j && j.user && j.user.id;
            } catch(_) { return null; }
        }

        function renderApprovalsTableWeb(state, opts) {
            const body = document.getElementById('approvalsBodyWeb');
            if (!body) return;
            const currentId = (window.currentDocumentState && window.currentDocumentState.currentDocument && window.currentDocumentState.currentDocument.id) || 'default-doc';
            const approvers = (state && state.approvers) ? state.approvers.slice().sort((a,b)=>a.order-b.order) : [];
            const isEditor = !!opts.isEditor;
            const actorId = opts.actorId;
            const summaryEl = document.getElementById('approvalsSummaryWeb');
            if (summaryEl) summaryEl.textContent = state && state.summary ? `(${state.summary.approvedCount}/${state.summary.totalUsers} approved)` : '';
            const addBtn = document.getElementById('approvalsAddUserWeb');
            if (addBtn) addBtn.style.display = isEditor ? 'inline-block' : 'none';

            let html = '';
            html += '<table>';
            html += '<thead><tr>' +
                (isEditor ? '<th style="width:40px;"></th>' : '') +
                '<th style="width:80px;">Order</th>' +
                '<th>Human</th>' +
                '<th style="width:110px;">Approved</th>' +
                '<th style="width:120px;">Remind</th>' +
                '<th>Notes</th>' +
            '</tr></thead>';
            html += '<tbody>';
            approvers.forEach((a, idx) => {
                const canAct = isEditor || a.userId === actorId;
                html += '<tr data-userid="'+a.userId+'" data-user-id="'+a.userId+'" data-user-name="'+(a.name || a.userId)+'">';
                if (isEditor) {
                    html += '<td><button class="btn btn-trash btn-del" title="Delete"><span class="icon-trash">🗑️</span></button></td>';
                }
                const max = approvers.length || (idx+1);
                html += '<td><select class="inp-order" '+(isEditor?'':'disabled')+' style="width:56px">';
                for (let n=1; n<=max; n++) { html += '<option value="'+n+'" '+((a.order||idx+1)===n?'selected':'')+'>'+n+'</option>'; }
                html += '</select></td>';
                html += '<td>'+ (a.name || a.userId) +'</td>';
                const checked = a.status === 'approved' ? 'checked' : '';
                html += '<td><input type="checkbox" class="chk-approved" '+checked+' '+(canAct?'':'disabled')+'></td>';
                html += '<td><button class="btn btn-secondary btn-remind" '+(canAct?'':'disabled')+'>Remind</button></td>';
                html += '<td><input type="text" maxlength="200" class="inp-notes" value="'+(a.notes||'').replace(/"/g,'&quot;')+'" '+(canAct?'':'disabled')+'></td>';
                html += '</tr>';
            });
            html += '</tbody></table>';
            body.innerHTML = html;

            const rows = Array.from(body.querySelectorAll('tbody tr'));
            rows.forEach((tr) => {
                const userId = tr.getAttribute('data-userid');
                const chk = tr.querySelector('.chk-approved');
                if (chk) {
                    chk.addEventListener('change', async () => {
                        try {
                            // If unchecking self, do it immediately. Otherwise require confirmation.
                            if (!chk.checked) {
                                if (actorId && userId === actorId) {
                                    await ApprovalsClient.reject({ documentId: currentId, targetUserId: userId, actorId: actorId, comment: '' });
                                    const st = await ApprovalsClient.getState({ documentId: currentId });
                                    renderApprovalsTableWeb(st, opts);
                                    return;
                                }
                                // revert until confirmed
                                chk.checked = true;
                                const modal = document.getElementById('approvalsModalWeb');
                                let bar = document.getElementById('approvalsConfirmRemoveWeb');
                                if (!bar) {
                                    bar = document.createElement('div');
                                    bar.id = 'approvalsConfirmRemoveWeb';
                                    bar.style.cssText = 'margin:8px 18px 0 18px; background:#fff3cd; color:#111827; border:1px solid #ffeeba; border-radius:6px; padding:8px 12px; display:flex; justify-content:space-between; align-items:center; gap:8px;';
                                    const host = document.getElementById('approvalsBodyWeb');
                                    if (host && host.parentNode) host.parentNode.insertBefore(bar, host);
                                    else modal && modal.insertBefore(bar, modal.firstChild);
                                }
                                const displayName = tr.getAttribute('data-user-name') || userId;
                                bar.innerHTML = `<div>You're about to remove approval for <b>${displayName}</b>. Continue?</div>`+
                                                  `<div style=\"display:flex; gap:8px;\">`+
                                                  `<button id=\"confirmRemoveWeb\" class=\"btn\">Confirm</button>`+
                                                  `<button id=\"cancelRemoveWeb\" class=\"btn btn-ghost\">Cancel</button>`+
                                                  `</div>`;
                                const btnRC = bar.querySelector('#confirmRemoveWeb');
                                const btnRX = bar.querySelector('#cancelRemoveWeb');
                                btnRC.onclick = async () => {
                                    try { btnRC.disabled=true; const did = await getWebCurrentDocId(); await ApprovalsClient.reject({ documentId: did, targetUserId: userId, actorId: actorId, comment: '' }); const st = await ApprovalsClient.getState({ documentId: did }); renderApprovalsTableWeb(st, opts); }
                                    catch(e){ console.error(e); }
                                    finally { try { bar.remove(); } catch(_) {} }
                                };
                                btnRX.onclick = () => { try { bar.remove(); } catch(_) {} };
                                return;
                            }
                            const isOnBehalf = Boolean(isEditor && actorId && userId !== actorId);
                            // Intercept only approve-on-behalf
                            if (chk.checked && isOnBehalf) {
                                // revert until confirmed
                                chk.checked = false;
                                // build/replace confirmation banner
                                const modal = document.getElementById('approvalsModalWeb');
                                let bar = document.getElementById('approvalsConfirmWeb');
                                if (!bar) {
                                    bar = document.createElement('div');
                                    bar.id = 'approvalsConfirmWeb';
                                    bar.style.cssText = 'margin:8px 18px 0 18px; background:#fff3cd; color:#111827; border:1px solid #ffeeba; border-radius:6px; padding:8px 12px; display:flex; justify-content:space-between; align-items:center; gap:8px;';
                                    const host = document.getElementById('approvalsBodyWeb');
                                    if (host && host.parentNode) host.parentNode.insertBefore(bar, host);
                                    else modal && modal.insertBefore(bar, modal.firstChild);
                                }
                                const displayName = tr.getAttribute('data-user-name') || userId;
                                bar.innerHTML = `<div>You're about to approve on behalf of <b>${displayName}</b>. Continue?</div>`+
                                                  `<div style="display:flex; gap:8px;">`+
                                                  `<button id="confirmApproveWeb" class="btn">Confirm</button>`+
                                                  `<button id="cancelApproveWeb" class="btn btn-ghost">Cancel</button>`+
                                                  `</div>`;
                                const btnC = bar.querySelector('#confirmApproveWeb');
                                const btnX = bar.querySelector('#cancelApproveWeb');
                                btnC.onclick = async () => {
                                    try { btnC.disabled=true; const did = await getWebCurrentDocId(); await ApprovalsClient.approve({ documentId: did, targetUserId: userId, actorId: actorId }); const st = await ApprovalsClient.getState({ documentId: did }); renderApprovalsTableWeb(st, opts); } catch(e){ console.error(e); }
                                    finally { try { bar.remove(); } catch(_) {} }
                                };
                                btnX.onclick = () => { try { bar.remove(); } catch(_) {} };
                                return;
                            }
                            // normal flow (self or reject)
                            if (chk.checked) {
                                const did = await getWebCurrentDocId();
                                await ApprovalsClient.approve({ documentId: did, targetUserId: userId, actorId: actorId });
                            } else {
                                const did = await getWebCurrentDocId();
                                await ApprovalsClient.reject({ documentId: did, targetUserId: userId, actorId: actorId, comment: '' });
                            }
                            const st = await ApprovalsClient.getState({ documentId: await getWebCurrentDocId() });
                            renderApprovalsTableWeb(st, opts);
                        } catch (e) { console.error('approve/reject error', e); }
                    });
                }
                const btnRem = tr.querySelector('.btn-remind');
                if (btnRem) {
                    // Everyone can remind everyone except themselves
                    const canRemind = userId !== actorId;
                    btnRem.disabled = !canRemind;
                    btnRem.addEventListener('click', async () => {
                        const nameCell = tr.querySelector('td:nth-child(' + (isEditor ? 3 : 2) + ')');
                        const displayName = (nameCell && nameCell.textContent ? nameCell.textContent.trim() : userId);
                        btnRem.disabled = true; const prev = btnRem.textContent; btnRem.textContent = 'Sending...';
                        try {
                            const did = await getWebCurrentDocId();
                            await ApprovalsClient.remind({ documentId: did, targetUserId: userId, actorId: actorId });
                            btnRem.textContent = `emailed ${displayName}`;
                            try { window.addNotification && window.addNotification(`emailed ${displayName}`, 'info'); } catch(_) {}
                            setTimeout(()=>{ btnRem.textContent = prev; btnRem.disabled = false; }, 5000);
                        } catch(e){ btnRem.textContent = prev; btnRem.disabled = false; }
                    });
                }
                const inpNotes = tr.querySelector('.inp-notes');
                if (inpNotes) {
                    inpNotes.addEventListener('change', async () => {
                        try { await ApprovalsClient.updateNotes({ documentId: currentId, targetUserId: userId, notes: inpNotes.value, actorId: actorId }); } catch(e){ console.error('notes error', e); }
                    });
                }
                const btnDel = tr.querySelector('.btn-del');
                if (btnDel) {
                    btnDel.addEventListener('click', async () => {
                        if (!confirm('Remove this approver from the list?')) return;
                        try { const did = await getWebCurrentDocId(); await ApprovalsClient.deleteUser({ documentId: did, targetUserId: userId, actorId: actorId }); const st = await ApprovalsClient.getState({ documentId: did }); renderApprovalsTableWeb(st, opts); } catch(e){ console.error('delete error', e); }
                    });
                }
            });

            // Auto-save order on change
            body.addEventListener('change', async (ev) => {
                const t = ev.target;
                if (!(t && t.classList && t.classList.contains('inp-order'))) return;
                    try {
                        const order = Array.from(body.querySelectorAll('tbody tr')).map((tr, i) => ({ userId: tr.getAttribute('data-userid'), order: Number(tr.querySelector('.inp-order')?.value || (i+1)) }));
                        const did = await getWebCurrentDocId();
                        await ApprovalsClient.reorder({ documentId: did, order, actorId: actorId });
                        const st = await ApprovalsClient.getState({ documentId: did });
                        renderApprovalsTableWeb(st, opts);
                    } catch(e){ console.error('reorder error', e); }
            });
            const refreshBtn = document.getElementById('approvalsRefreshWeb');
            if (refreshBtn) {
                refreshBtn.onclick = async () => { const st = await ApprovalsClient.getState({ documentId: await getWebCurrentDocId() }); console.log('Hitting the Refresh!'); renderApprovalsTableWeb(st, opts); };
            }
            const resetBtn = document.getElementById('approvalsResetWeb');
            if (resetBtn) {
                resetBtn.style.display = isEditor ? 'inline-block' : 'none';
                resetBtn.onclick = async () => {
                    if (!confirm('This will reset approvals to the canonical set and clear all statuses. Continue?')) return;
                    try { resetBtn.disabled = true; const prev=resetBtn.textContent; resetBtn.textContent='Nuking…'; const did = await getWebCurrentDocId(); await fetch('http://localhost:3001/api/approvals/reset', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ actorId, documentId: did }) }); const st = await ApprovalsClient.getState({ documentId: did }); renderApprovalsTableWeb(st, opts); } catch(e){ console.error('reset error', e); } finally { resetBtn.disabled=false; resetBtn.textContent='Nuke it'; }
                };
            }
            const addBtn2 = document.getElementById('approvalsAddUserWeb');
            if (addBtn2) {
                addBtn2.onclick = async () => {
                    const name = prompt('Name'); if (!name) return; const email = prompt('Email'); if (!email) return;
                    try { const did = await getWebCurrentDocId(); await ApprovalsClient.addUser({ documentId: did, name, email, actorId: actorId }); const st = await ApprovalsClient.getState({ documentId: did }); renderApprovalsTableWeb(st, opts); } catch(e){ alert((e && e.message) || 'Add user failed'); }
                };
            }
        }

        window.openApprovalsModalWeb = async function() {
            try {
                const actorId = await getWebActorId();
                const statusResp = await fetch('http://localhost:3001/api/status');
                const statusJson = await statusResp.json();
                const isEditor = !!(statusJson && statusJson.platformUsers && statusJson.platformUsers.web && statusJson.platformUsers.web.role === 'editor');
                const currentId = (window.currentDocumentState && window.currentDocumentState.currentDocument && window.currentDocumentState.currentDocument.id) || 'default-doc';
                const state = await ApprovalsClient.getState({ documentId: currentId });
                if (typeof window.openModalById === 'function') {
                    window.openModalById('approvalsModalWeb');
                } else {
                    document.getElementById('approvalsModalWeb').style.display = 'block';
                }
                renderApprovalsTableWeb(state, { actorId, isEditor });
            } catch (e) {
                console.error('Approvals open error (web):', e);
                alert('Failed to load approvals state');
            }
        };
    </script>

     <!-- Templates Modal (Web) -->
     <style id="templates-modal-styles">
         /* Scoped styles so they only affect the templates modal */
         #templatesModalWeb .badge-toggle {
             /* Reset problematic inherited styles */
             animation: none !important;
             position: relative !important;
             z-index: 1 !important;
             display: inline-block !important;
             padding: 4px 10px !important;
             border: 1px solid #111 !important;
             border-radius: 999px !important;
             background: #f3f4f6 !important;
             color: #111 !important;
             font-weight: 600 !important;
             cursor: pointer !important;
             line-height: 1.2 !important;
             white-space: nowrap !important;
         }
         #templatesModalWeb .badge-toggle:hover { background: #e5e7eb !important; }
         #templatesModalWeb .badge-toggle[data-kind="status"] {
             background: #e0f2fe !important;
             border-color: #0369a1 !important;
             color: #0c4a6e !important;
         }
         #templatesModalWeb .badge-toggle[data-kind="checkout"] {
             background: #dcfce7 !important;
             border-color: #16a34a !important;
             color: #065f46 !important;
         }
     </style>
    <div id="templatesModalWeb" style="display:none !important; position: fixed !important; inset: 0 !important; width:100vw !important; height:100vh !important; background: rgba(0,0,0,0.5) !important; z-index: 2147483647 !important; pointer-events:auto !important;">
        <div style="position: absolute !important; top: 50% !important; left: 50% !important; transform: translate(-50%, -50%) !important; background: white !important; border-radius: 8px !important; padding: 16px !important; width: 720px !important; max-width: 92vw !important; box-shadow: 0 10px 30px rgba(0,0,0,0.2) !important; z-index: 2147483647 !important; pointer-events:auto !important;">
             <h2 style="margin: 0 0 12px 0; font-size: 16px;">Templates</h2>
             <div style="overflow: auto; max-height: 60vh;">
                 <table style="width: 100%; border-collapse: collapse; font-size: 13px;">
                     <thead>
                         <tr style="background:#f8fafc; text-align:left;">
                             <th style="padding:8px; border-bottom:1px solid #e5e7eb;">File name</th>
                             <th style="padding:8px; border-bottom:1px solid #e5e7eb;">Status</th>
                             <th style="padding:8px; border-bottom:1px solid #e5e7eb;">Owner</th>
                             <th style="padding:8px; border-bottom:1px solid #e5e7eb;">Check-out</th>
                         </tr>
                     </thead>
                     <tbody>
                         <tr>
                             <td style="padding:8px; border-bottom:1px solid #f1f5f9;">Services template</td>
                             <td style="padding:8px; border-bottom:1px solid #f1f5f9;"><button class="badge-toggle" data-kind="status">Draft</button></td>
                             <td style="padding:8px; border-bottom:1px solid #f1f5f9;">Mo-templates</td>
                             <td style="padding:8px; border-bottom:1px solid #f1f5f9;"><button class="badge-toggle" data-kind="checkout">Free</button></td>
                         </tr>
                         <tr>
                             <td style="padding:8px; border-bottom:1px solid #f1f5f9;">Public works template</td>
                             <td style="padding:8px; border-bottom:1px solid #f1f5f9;"><button class="badge-toggle" data-kind="status">Draft</button></td>
                             <td style="padding:8px; border-bottom:1px solid #f1f5f9;">Mo-templates</td>
                             <td style="padding:8px; border-bottom:1px solid #f1f5f9;"><button class="badge-toggle" data-kind="checkout">Free</button></td>
                         </tr>
                         <tr>
                             <td style="padding:8px; border-bottom:1px solid #f1f5f9;">Software renewal template</td>
                             <td style="padding:8px; border-bottom:1px solid #f1f5f9;"><button class="badge-toggle" data-kind="status">Draft</button></td>
                             <td style="padding:8px; border-bottom:1px solid #f1f5f9;">Mo-templates</td>
                             <td style="padding:8px; border-bottom:1px solid #f1f5f9;"><button class="badge-toggle" data-kind="checkout">Free</button></td>
                         </tr>
                     </tbody>
                 </table>
             </div>
             <div style="display:flex; justify-content:flex-end; gap:8px; margin-top:12px;">
                 <button id="templatesCloseBtnWeb" class="btn-templates">Close</button>
             </div>
         </div>
     </div>

    <script>
        window.openTemplatesModal = function(){
            window.openModalById && window.openModalById('templatesModalWeb');
        };
        (function(){
            var modal = document.getElementById('templatesModalWeb');
            var closeBtn = document.getElementById('templatesCloseBtnWeb');
            function close(){ if(modal) modal.style.setProperty('display','none','important'); }
            if(closeBtn) closeBtn.addEventListener('click', close);
            if(modal) modal.addEventListener('click', function(e){ if(e.target===modal) close(); });
            document.addEventListener('keydown', function(e){ if(e.key==='Escape' && modal && modal.style.display==='block') close(); });
            document.addEventListener('click', function(e){
                var t = e.target;
                if(!(t && t.classList && t.classList.contains('badge-toggle'))) return;
                var kind = t.getAttribute('data-kind');
                if(kind==='status'){
                    t.textContent = (t.textContent==='Draft') ? 'Live' : 'Draft';
                } else if(kind==='checkout'){
                    var next = (t.textContent==='Free') ? 'Checked out' : 'Free';
                    var row = t.closest && t.closest('tr');
                    var nameCell = row && row.cells && row.cells[0];
                    var name = nameCell ? (nameCell.textContent || '').trim() : 'Template';
                    if(next==='Checked out'){
                        // Native confirm is fine on web
                        var ok = true;
                        try { ok = window.confirm('In the future this button will open your template right here.'); } catch(_) {}
                        if(!ok) return;
                        console.log('Checked out:', name);
                    }
                    t.textContent = next;
                }
            });
        })();
    </script>

    // ... existing code ...
          // Centralized approvals UI refresh (web): resolves docId, fetches state, updates pill, refreshes modal
          (function(){
              let t = null;
              async function refresh(opts={}){
                  try {
                      const docId = await (typeof getWebCurrentDocId === 'function' ? getWebCurrentDocId() : (async () => {
                          const d = await fetch('http://localhost:3001/api/current-document', { cache:'no-store' }).then(r=>r.json());
                          return (d && (d.id||d.documentId)) ? (d.id||d.documentId) : 'doc-current';
                      })());
                      const st = await fetch(`http://localhost:3001/api/approvals/state?documentId=${encodeURIComponent(docId)}`, { cache:'no-store' }).then(r=>r.json());
                      const sum = st && st.summary ? st.summary : { approvedCount:0, totalUsers:0 };
                      if (typeof window.__updateApprovalsPillWeb === 'function') {
                          window.__updateApprovalsPillWeb(sum.approvedCount || 0, sum.totalUsers || 0);
                      }
                      try { await refreshUsersModal(); } catch(_) {}
                  } catch (e) { console.warn('WEB UISync refresh failed', e); }
              }
              window.ApprovalsUISyncWeb = {
                  refreshDebounced(opts={}){
                      if (t) clearTimeout(t);
                      t = setTimeout(() => { refresh(opts); }, 100);
                  },
                  refresh
              };
          })();
// ... existing code ...
</body>

</html>